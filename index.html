<html lang="fr"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bases Vectorielles et Moteurs de Similarité pour l'IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }
        
        .formula {
            padding: 0.5rem;
            margin: 1rem 0;
            background-color: #f1f5f9;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        .text-sm {
            line-height: 2.18rem !important;
        }
        
        .nav-item {
            transition: all 0.3s ease;
        }
        
        .nav-item:hover {
            transform: translateY(-2px);
        }
        
        .card {
            transition: all 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .algorithm-card {
            height: 100%;
            transition: all 0.3s ease;
        }
        
        .algorithm-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .vector-animation {
            position: relative;
            height: 300px;
            width: 100%;
            background-color: #f1f5f9;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .card {
            transition: all 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .vector {
            position: absolute;
            width: 4px;
            height: 0;
            background-color: #3b82f6;
            transform-origin: bottom center;
            bottom: 50%;
            left: 50%;
            transition: height 1s ease;
        }
        
        .vector-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #1e40af;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
                .code-container {
            position: relative;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: #2d2d2d;
            color: #9da5b4;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }
        
        .copy-btn {
            background-color: #3a3f4b;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }
        
        .copy-btn:hover {
            background-color: #4e5565;
        }
        
        .copy-btn.copied {
            background-color: #2e7d32;
        }
        
        pre {
            margin: 0;
            padding: 16px;
            overflow-x: auto;
        }
        
        code {
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .vector-label {
            position: absolute;
            font-size: 12px;
            color: #1e293b;
            transform: translate(-50%, -100%);
            text-align: center;
            width: 60px;
        }
        
        .highlight {
            background: linear-gradient(120deg, rgba(56, 189, 248, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%);
            padding: 0 0.25rem;
            border-radius: 0.25rem;
        }
        
        .comparison-table th, .comparison-table td {
            padding: 0.75rem 1rem;
            text-align: left;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f1f5f9;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted #3b82f6;
            cursor: help;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #1e293b;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.875rem;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.sticky{position:sticky}.top-0{top:0px}.z-50{z-index:50}.mx-auto{margin-left:auto;margin-right:auto}.-mb-px{margin-bottom:-1px}.mb-10{margin-bottom:2.5rem}.mb-16{margin-bottom:4rem}.mb-2{margin-bottom:0.5rem}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.mr-4{margin-right:1rem}.mt-2{margin-top:0.5rem}.mt-4{margin-top:1rem}.mt-6{margin-top:1.5rem}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.hidden{display:none}.h-12{height:3rem}.h-16{height:4rem}.h-6{height:1.5rem}.w-12{width:3rem}.w-6{width:1.5rem}.w-full{width:100%}.min-w-full{min-width:100%}.max-w-2xl{max-width:42rem}.max-w-3xl{max-width:48rem}.max-w-7xl{max-width:80rem}.max-w-lg{max-width:32rem}.max-w-md{max-width:28rem}.list-decimal{list-style-type:decimal}.list-disc{list-style-type:disc}.grid-cols-1{grid-template-columns:repeat(1, minmax(0, 1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-6{gap:1.5rem}.gap-8{gap:2rem}.space-x-8 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(2rem * var(--tw-space-x-reverse));margin-left:calc(2rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-1 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0.25rem * var(--tw-space-y-reverse))}.space-y-2 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0.5rem * var(--tw-space-y-reverse))}.overflow-x-auto{overflow-x:auto}.whitespace-nowrap{white-space:nowrap}.rounded-lg{border-radius:0.5rem}.border-b{border-bottom-width:1px}.border-b-2{border-bottom-width:2px}.border-blue-500{--tw-border-opacity:1;border-color:rgb(59 130 246 / var(--tw-border-opacity, 1))}.border-gray-200{--tw-border-opacity:1;border-color:rgb(229 231 235 / var(--tw-border-opacity, 1))}.border-transparent{border-color:transparent}.bg-blue-100{--tw-bg-opacity:1;background-color:rgb(219 234 254 / var(--tw-bg-opacity, 1))}.bg-blue-50{--tw-bg-opacity:1;background-color:rgb(239 246 255 / var(--tw-bg-opacity, 1))}.bg-gray-100{--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity, 1))}.bg-gray-50{--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))}.bg-gray-800{--tw-bg-opacity:1;background-color:rgb(31 41 55 / var(--tw-bg-opacity, 1))}.bg-green-100{--tw-bg-opacity:1;background-color:rgb(220 252 231 / var(--tw-bg-opacity, 1))}.bg-purple-100{--tw-bg-opacity:1;background-color:rgb(243 232 255 / var(--tw-bg-opacity, 1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-gradient-to-r{background-image:linear-gradient(to right, var(--tw-gradient-stops))}.from-blue-600{--tw-gradient-from:#2563eb var(--tw-gradient-from-position);--tw-gradient-to:rgb(37 99 235 / 0) var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to)}.to-indigo-700{--tw-gradient-to:#4338ca var(--tw-gradient-to-position)}.p-3{padding:0.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.px-1{padding-left:0.25rem;padding-right:0.25rem}.px-4{padding-left:1rem;padding-right:1rem}.py-12{padding-top:3rem;padding-bottom:3rem}.py-4{padding-top:1rem;padding-bottom:1rem}.py-8{padding-top:2rem;padding-bottom:2rem}.pb-2{padding-bottom:0.5rem}.pl-6{padding-left:1.5rem}.pt-1{padding-top:0.25rem}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-semibold{font-weight:600}.leading-5{line-height:1.25rem}.text-blue-600{--tw-text-opacity:1;color:rgb(37 99 235 / var(--tw-text-opacity, 1))}.text-blue-700{--tw-text-opacity:1;color:rgb(29 78 216 / var(--tw-text-opacity, 1))}.text-blue-800{--tw-text-opacity:1;color:rgb(30 64 175 / var(--tw-text-opacity, 1))}.text-gray-100{--tw-text-opacity:1;color:rgb(243 244 246 / var(--tw-text-opacity, 1))}.text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity, 1))}.text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity, 1))}.text-gray-800{--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity, 1))}.text-green-600{--tw-text-opacity:1;color:rgb(22 163 74 / var(--tw-text-opacity, 1))}.text-green-700{--tw-text-opacity:1;color:rgb(21 128 61 / var(--tw-text-opacity, 1))}.text-purple-600{--tw-text-opacity:1;color:rgb(147 51 234 / var(--tw-text-opacity, 1))}.text-purple-700{--tw-text-opacity:1;color:rgb(126 34 206 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.shadow{--tw-shadow:0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.transition{transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-150{transition-duration:150ms}.ease-in-out{transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.hover\:border-gray-300:hover{--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1))}.hover\:text-gray-700:hover{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity, 1))}.focus\:border-gray-300:focus{--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity, 1))}.focus\:text-gray-700:focus{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity, 1))}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}@media (min-width: 640px){.sm\:px-6{padding-left:1.5rem;padding-right:1.5rem}}@media (min-width: 768px){.md\:mb-0{margin-bottom:0px}.md\:grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}.md\:flex-row{flex-direction:row}}@media (min-width: 1024px){.lg\:col-span-2{grid-column:span 2 / span 2}.lg\:grid-cols-3{grid-template-columns:repeat(3, minmax(0, 1fr))}.lg\:px-8{padding-left:2rem;padding-right:2rem}}</style></head>
<body>
    <!-- Header -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 text-white py-12 px-4 sm:px-6 lg:px-8">
        <div class="max-w-7xl mx-auto">
            <h1 class="text-4xl font-bold mb-4">Bases Vectorielles et Moteurs de Similarité pour l'IA</h1>
            <p class="text-xl max-w-3xl">Une exploration des fondements mathématiques, des algorithmes de recherche approximative et des systèmes de bases de données vectorielles qui alimentent les applications modernes d'intelligence artificielle.</p>
        </div>
    </header>
    
    <!-- Navigation -->
    <nav class="bg-white shadow-md sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex space-x-8 overflow-x-auto">
                    <a href="#introduction" class="nav-item inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out">
                        Introduction
                    </a>
                    <a href="#fondements" class="nav-item inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out">
                        Fondements Mathématiques
                    </a>
                    <a href="#algorithmes" class="nav-item inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out">
                        Algorithmes ANN
                    </a>
                    <a href="#systemes" class="nav-item inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out">
                        Systèmes de Bases Vectorielles
                    </a>
                </div>
            </div>
        </div>
    </nav>
    <!-- Table of Contents (TOC) -->
    <nav id="toc" class="fixed top-24 left-6 z-40 bg-white/90 shadow-lg rounded-xl border border-blue-100 p-5 w-72 max-w-xs hidden lg:block transition-all duration-300 opacity-0 pointer-events-none">
        <h2 class="text-lg font-bold text-blue-700 mb-3 flex items-center gap-2">
            <svg class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
            Sommaire
        </h2>
        <ul class="space-y-2 text-sm">
            <li>
                <a href="#introduction" class="toc-link text-blue-700 hover:underline hover:text-blue-900 transition">Introduction</a>
            </li>
            <li>
                <a href="#fondements" class="toc-link text-blue-700 hover:underline hover:text-blue-900 transition">1. Fondements Mathématiques</a>
                <ul class="ml-4 mt-1 space-y-1 border-l border-blue-100 pl-3">
                    <li><a href="#fondements" class="toc-link text-blue-600 hover:underline">1.1 Définition & Propriétés</a></li>
                    <li><a href="#fondements2" class="toc-link text-blue-600 hover:underline">1.2 Propriétés Désirables</a></li>
                    <li><a href="#fondements3" class="toc-link text-blue-600 hover:underline">1.3 Métriques de Distance</a></li>
                </ul>
            </li>
            <li>
                <a href="#algorithmes" class="toc-link text-blue-700 hover:underline hover:text-blue-900 transition">2. Algorithmes ANN</a>
                <ul class="ml-4 mt-1 space-y-1 border-l border-blue-100 pl-3">
                    <li><a href="#algorithmes" class="toc-link text-blue-600 hover:underline">2.1 Problématique</a></li>
                    <li><a href="#algorithmes2" class="toc-link text-blue-600 hover:underline">2.2 Approches Algorithmiques</a></li>
                    <li><a href="#algorithmes3" class="toc-link text-blue-600 hover:underline">2.3 Complexité & Curse</a></li>
                </ul>
            </li>
            <li>
                <a href="#systemes" class="toc-link text-blue-700 hover:underline hover:text-blue-900 transition">3. Systèmes de Bases Vectorielles</a>
                <ul class="ml-4 mt-1 space-y-1 border-l border-blue-100 pl-3">
                    <li><a href="#systemes" class="toc-link text-blue-600 hover:underline">3.1 Faiss</a></li>
                    <li><a href="#systemes2" class="toc-link text-blue-600 hover:underline">3.2 Milvus</a></li>
                    <li><a href="#systemes3" class="toc-link text-blue-600 hover:underline">3.3 Pinecone</a></li>
                </ul>
            </li>
            <li>
                <a href="#demo" class="toc-link text-blue-700 hover:underline hover:text-blue-900 transition">Démo: Recherche Sémantique</a>
            </li>
        </ul>
    </nav>
    <style>
    #toc {
        box-shadow: 0 8px 32px 0 rgba(59,130,246,0.10), 0 1.5px 6px 0 rgba(59,130,246,0.06);
        backdrop-filter: blur(2px);
        max-height: 80vh;
        overflow-y: auto;
        scrollbar-width: thin;
        transition: opacity 0.3s, pointer-events 0.3s;
    }
    #toc::-webkit-scrollbar { width: 6px; background: #e0e7ff; }
    #toc::-webkit-scrollbar-thumb { background: #c7d2fe; border-radius: 8px; }
    .toc-link.active {
        font-weight: 600;
        color: #2563eb !important;
        background: linear-gradient(90deg, #dbeafe 40%, #f1f5f9 100%);
        border-radius: 0.375rem;
        padding-left: 0.25rem;
    }
    @media (max-width: 1023px) {
        #toc { display: none !important; }
    }
    </style>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Smooth scroll for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href && href.startsWith('#')) {
                    const target = document.querySelector(href);
                    if (target) {
                        e.preventDefault();
                        window.scrollTo({
                            top: target.getBoundingClientRect().top + window.scrollY - 80,
                            behavior: 'smooth'
                        });
                    }
                }
            });
        });

        // Highlight active section in TOC
        const tocLinks = document.querySelectorAll('.toc-link');
        const sectionIds = ['#introduction', '#fondements', '#algorithmes', '#systemes', '#demo'];
        const sectionEls = sectionIds.map(id => document.querySelector(id));
        function updateTOCActive() {
            let idx = 0;
            for (let i = 0; i < sectionEls.length; i++) {
                if (sectionEls[i] && window.scrollY + 100 >= sectionEls[i].offsetTop) {
                    idx = i;
                }
            }
            tocLinks.forEach(link => link.classList.remove('active'));
            // Highlight all links for the current section
            tocLinks.forEach(link => {
                if (link.getAttribute('href') === sectionIds[idx]) {
                    link.classList.add('active');
                }
            });
        }
        window.addEventListener('scroll', updateTOCActive, { passive: true });
        updateTOCActive();

        // Show/hide TOC after 400px scroll
        const toc = document.getElementById('toc');
        function handleTOCVisibility() {
            if (window.scrollY > 200) {
                toc.classList.remove('opacity-0', 'pointer-events-none');
                toc.classList.add('opacity-100');
            } else {
                toc.classList.add('opacity-0', 'pointer-events-none');
                toc.classList.remove('opacity-100');
            }
        }
        window.addEventListener('scroll', handleTOCVisibility, { passive: true });
        handleTOCVisibility();
    });
    </script>
    
    <main class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <!-- Introduction -->
        <section id="introduction" class="mb-16">
            <h2 class="text-3xl font-bold mb-6 text-gray-800 border-b pb-2">Introduction</h2>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div class="lg:col-span-2">
                    <p class="mb-4"></p>
                        <span class="bg-gradient-to-r to-indigo-100 px-2 py-1 rounded-lg"></span>
                            Les systèmes d'<span class="font-semibold text-blue-700">IA modernes</span> reposent fondamentalement sur la capacité à représenter des données complexes (texte, images, son) sous forme de <span class="font-semibold text-indigo-700">vecteurs numériques</span> dans des espaces de grande dimension.
                        </span>
                        <br>
                        <span class="bg-gradient-to-r to-blue-50 px-2 py-1 rounded-lg"></span>
                            Cette transformation, appelée <span class="font-semibold text-purple-700">"embedding"</span>, permet de capturer la <span class="font-semibold text-blue-700">sémantique</span> des données et d'effectuer des opérations mathématiques sur celles-ci.
                        </span>
                    </p>
                    
                    <p class="mb-4"></p>
                        <span class="bg-gradient-to-r from-green-100 to-blue-50 px-2 py-1 rounded-lg">
                            La <span class="font-semibold text-green-700">recherche de similarité vectorielle</span> est devenue un composant critique pour de nombreuses applications d'IA :
                        </span>
                    </p>
                    
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li>
                            <span class="bg-gradient-to-r from-blue-200 to-blue-50 px-2 rounded text-blue-800 font-medium">Systèmes RAG (Retrieval-Augmented Generation)</span>
                        </li>
                        <li>
                            <span class="bg-gradient-to-r from-green-200 to-green-50 px-2 rounded text-green-800 font-medium">Moteurs de recommandation</span>
                        </li>
                        <li>
                            <span class="bg-gradient-to-r from-purple-200 to-purple-50 px-2 rounded text-purple-800 font-medium">Recherche sémantique</span>
                        </li>
                        <li>
                            <span class="bg-gradient-to-r from-yellow-100 to-yellow-50 px-2 rounded text-yellow-800 font-medium">Détection d'anomalies</span>
                        </li>
                        <li>
                            <span class="bg-gradient-to-r from-pink-100 to-pink-50 px-2 rounded text-pink-800 font-medium">Reconnaissance faciale et vocale</span>
                        </li>
                    </ul>
                </div>
                <div class="flex items-center justify-center">
                    <div class="bg-gradient-to-br from-blue-100 via-indigo-100 to-purple-100 rounded-xl shadow-lg p-6 flex flex-col items-center">
                        <svg width="80" height="80" viewBox="0 0 80 80" fill="none">
                            <circle cx="40" cy="40" r="36" fill="#dbeafe" stroke="#6366f1" stroke-width="3"/>
                            <circle cx="40" cy="40" r="22" fill="#f3e8ff" stroke="#a78bfa" stroke-width="2"/>
                            <circle cx="40" cy="40" r="8" fill="#a5b4fc" stroke="#6366f1" stroke-width="2"/>
                            <line x1="40" y1="40" x2="40" y2="10" stroke="#6366f1" stroke-width="2" stroke-linecap="round"/>
                            <line x1="40" y1="40" x2="70" y2="40" stroke="#6366f1" stroke-width="2" stroke-linecap="round"/>
                            <line x1="40" y1="40" x2="15" y2="60" stroke="#6366f1" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <span class="mt-4 text-blue-700 font-semibold text-lg text-center">Espace vectoriel<br>et embeddings</span>
                    </div>
                </div>
            </div></ul>
                <div class="bg-white rounded-lg shadow-lg p-6 card">
                    <h3 class="text-xl font-semibold mb-4 text-blue-700">Qu'est-ce qu'un Embedding?</h3>
                    <div class="vector-animation mb-4" id="embedding-animation">
                        <!-- Animation will be inserted here by JS -->
                    <svg width="100%" height="100%" viewBox="0 0 300 200"><g><rect x="20" y="40" width="80" height="30" rx="4" fill="#bfdbfe" stroke="#3b82f6" stroke-width="1"></rect><text x="60" y="60" text-anchor="middle" fill="#1e40af" font-size="12">Texte</text><rect x="20" y="90" width="80" height="60" rx="4" fill="#c7d2fe" stroke="#6366f1" stroke-width="1"></rect><line x1="30" y1="110" x2="50" y2="110" stroke="#4f46e5" stroke-width="2"></line><line x1="30" y1="120" x2="70" y2="120" stroke="#4f46e5" stroke-width="2"></line><line x1="30" y1="130" x2="60" y2="130" stroke="#4f46e5" stroke-width="2"></line><text x="60" y="155" text-anchor="middle" fill="#4f46e5" font-size="12">Image</text></g><rect x="130" y="70" width="60" height="60" rx="8" fill="#fef3c7" stroke="#d97706" stroke-width="2"></rect><text x="160" y="105" text-anchor="middle" fill="#92400e" font-size="12">Modèle</text><rect x="220" y="40" width="60" height="120" rx="4" fill="#dbeafe" stroke="#3b82f6" stroke-width="1"></rect><line x1="250" y1="100" x2="250" y2="70" stroke="#3b82f6" stroke-width="2"></line><polygon points="250,65 246,72 254,72" fill="#3b82f6"></polygon><line x1="250" y1="100" x2="270" y2="80" stroke="#6366f1" stroke-width="2"></line><polygon points="274,76 266,78 270,86" fill="#6366f1"></polygon><text x="250" y="175" text-anchor="middle" fill="#1e40af" font-size="12">Espace Vectoriel</text><line x1="100" y1="55" x2="125" y2="85" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="4"></line><line x1="100" y1="120" x2="125" y2="100" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="4"></line><line x1="190" y1="100" x2="215" y2="100" stroke="#94a3b8" stroke-width="1.5"></line><polygon points="215,100 210,96 210,104" fill="#94a3b8"></polygon></svg></div>
                    <p class="text-sm text-gray-600">Un embedding transforme des données complexes (texte, image, son) en vecteurs numériques qui préservent les relations sémantiques. Des objets similaires sont proches dans l'espace vectoriel.</p>
                    <div class="flex justify-center my-6 gap-4">
                        <div class="relative group">
                            <img src="./embeddings.png" alt="Embeddings" class="rounded-2xl shadow-lg border-4 border-blue-100 bg-white" style="max-width: 620px; height:440px; object-fit: cover;">
                            <button class="zoom-btn absolute bottom-2 right-2 bg-white bg-opacity-80 rounded-full p-2 shadow hover:bg-blue-100 transition" data-img="./embeddings.png" aria-label="Zoom">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <circle cx="11" cy="11" r="7" stroke-width="2" stroke="currentColor" fill="none"/>
                                    <line x1="16" y1="16" x2="21" y2="21" stroke-width="2" stroke="currentColor"/>
                                </svg>
                            </button>
                        </div>
                        <div class="relative group">
                            <img src="./word2vec.png" alt="Embeddings" class="rounded-2xl shadow-lg border-4 border-blue-100 bg-white" style="max-width: 620px; object-fit: cover;">
                            <button class="zoom-btn absolute bottom-2 right-2 bg-white bg-opacity-80 rounded-full p-2 shadow hover:bg-blue-100 transition" data-img="./word2vec.png" aria-label="Zoom">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <circle cx="11" cy="11" r="7" stroke-width="2" stroke="currentColor" fill="none"/>
                                    <line x1="16" y1="16" x2="21" y2="21" stroke-width="2" stroke="currentColor"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <!-- Zoom Popup Modal -->
                    <div id="zoom-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
                        <div class="relative">
                            <img id="zoom-modal-img" src="" alt="Zoom" class="max-h-[90vh] max-w-[90vw] rounded-2xl shadow-2xl border-4 border-blue-200 bg-white">
                            <button id="zoom-modal-close" class="absolute top-2 right-2 bg-white bg-opacity-90 rounded-full p-2 shadow hover:bg-blue-100 transition" aria-label="Fermer">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7 text-blue-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <line x1="6" y1="6" x2="18" y2="18" stroke-width="2" stroke="currentColor"/>
                                    <line x1="6" y1="18" x2="18" y2="6" stroke-width="2" stroke="currentColor"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <script>
                    document.addEventListener('DOMContentLoaded', function() {
                        // Zoom button click
                        document.querySelectorAll('.zoom-btn').forEach(btn => {
                            btn.addEventListener('click', function(e) {
                                e.stopPropagation();
                                const imgSrc = btn.getAttribute('data-img');
                                const modal = document.getElementById('zoom-modal');
                                const modalImg = document.getElementById('zoom-modal-img');
                                modalImg.src = imgSrc;
                                modal.classList.remove('hidden');
                            });
                        });
                        // Close modal on button or background click
                        document.getElementById('zoom-modal-close').onclick = function(e) {
                            e.stopPropagation();
                            document.getElementById('zoom-modal').classList.add('hidden');
                            document.getElementById('zoom-modal-img').src = '';
                        };
                        document.getElementById('zoom-modal').addEventListener('click', function(e) {
                            if (e.target === this) {
                                this.classList.add('hidden');
                                document.getElementById('zoom-modal-img').src = '';
                            }
                        });
                        // Optional: close on ESC
                        document.addEventListener('keydown', function(e) {
                            if (e.key === 'Escape') {
                                document.getElementById('zoom-modal').classList.add('hidden');
                                document.getElementById('zoom-modal-img').src = '';
                            }
                        });
                    });
                    </script></button>
                </div>
            </div>
        </section>
        
        <!-- Fondements Mathématiques -->
        <section id="fondements" class="mb-16 bg-gradient-to-br from-blue-50 via-white to-purple-50 rounded-2xl shadow-xl p-8 card border-l-8 border-blue-400">
            <h2 class="text-4xl font-extrabold mb-8 text-blue-800 border-b-2 border-blue-200 pb-3 tracking-tight drop-shadow">1. Fondements Mathématiques des Embeddings</h2>
            
            <!-- 1.1 Définition Formelle -->
            <div class="mb-12">
                <h3 class="text-2xl font-bold mb-4 text-blue-700 flex items-center gap-2">
                    <span class="inline-block w-2 h-2 rounded-full bg-blue-400"></span>
                    1.1 Définition Formelle et Propriétés Mathématiques
                </h3>
                <p class="mb-4 text-lg leading-relaxed">
                    Un <span class="font-semibold text-blue-700">embedding</span> est une application 
                    <span class="formula bg-blue-100 px-2 py-1 rounded">\( f : X \rightarrow \mathbb{R}^d \)</span>
                    qui associe à chaque objet <span class="formula">\(x \in X\)</span> (texte, image, etc.) un vecteur 
                    <span class="formula">\(f(x) \in \mathbb{R}^d\)</span> dans un espace euclidien de dimension <span class="formula">d</span>.
                </p>
                <p class="mb-4 text-lg leading-relaxed">
                    L'objectif est de préserver la structure sémantique de <span class="formula">X</span> dans l'espace vectoriel, c'est-à-dire que la similarité sémantique entre <span class="formula">x</span> et <span class="formula">y</span> soit reflétée par une fonction de similarité ou de distance sur leurs embeddings :
                </p>
                <div class="formula text-center mb-6 text-xl bg-blue-50 rounded-lg py-2 px-4 shadow">
                    \[ \forall x, y \in X, \quad \text{sim}_X(x, y) \approx g(f(x), f(y)) \]
                </div>
                <p class="mb-6 text-base text-gray-700">
                    où <span class="formula">\(\text{sim}_X\)</span> est une mesure de similarité dans <span class="formula">X</span> (souvent implicite), et <span class="formula">g</span> une fonction de similarité (cosinus, produit scalaire, etc.) ou de distance (euclidienne, etc.) dans <span class="formula">\(\mathbb{R}^d\)</span>.
                </p><h4 class="font-semibold mb-2 text-blue-700 text-lg">Exemple&nbsp;: Similarité cosinus</h4>
                <div class="bg-gradient-to-r from-blue-100 to-blue-50 rounded-xl p-5 mb-6 shadow flex flex-col md:flex-row items-center gap-6">
                    
                    <div class="" style="display: flex; justify-content: center; align-items: center; position: relative; left: 0; right:0;"></div>
                        
                        <div class="formula text-center text-xl mb-2">
                            \[\text{sim}_{\cos}(u, v) = \frac{u \cdot v}{\|u\| \|v\|} \approx \cos(\theta)\]
                        </div>                             
                        <p class="text-sm mt-2 text-blue-900" style="max-width: 430px;">Deux objets sémantiquement proches auront des vecteurs dont l'angle est faible (similarité proche de 1).</p>
                        <div class="flex-shrink-0 flex justify-center items-center">
                                <svg width="140" height="140" viewBox="0 0 140 140">
                                    <circle cx="70" cy="70" r="60" fill="#e0e7ff"/>
                                    <line x1="70" y1="70" x2="130" y2="70" stroke="#6366f1" stroke-width="5" />
                                    <line x1="70" y1="70" x2="110" y2="30" stroke="#38bdf8" stroke-width="5" />
                                    <path d="M110 30 A40 40 0 0 1 130 70" fill="none" stroke="#f59e42" stroke-width="3"/>
                                    <text x="120" y="45" font-size="22" fill="#f59e42" font-weight="bold">θ</text>
                                </svg>
                            </div>
                        
                    </div>
                </div>
                <div class="mb-6">
                    <h4 class="font-semibold mb-2 text-blue-800">Propriétés mathématiques souhaitées</h4>
                    <ul class="list-disc pl-8 space-y-1 text-base text-gray-700">
                        <li><span class="font-medium text-blue-700">Injectivité locale :</span> des objets différents doivent avoir des vecteurs distincts.</li>
                        <li><span class="font-medium text-blue-700">Préservation des voisinages :</span> si <span class="formula">\(x \approx y\)</span> alors <span class="formula">\(\|f(x) - f(y)\|\)</span> est petit.</li>
                        <li><span class="font-medium text-blue-700">Linéarité (pour certaines tâches) :</span> des relations sémantiques se traduisent par des opérations vectorielles (ex: analogies).</li>
                    </ul>
                </div>
                <div class="mb-8">
                    <h4 class="font-semibold mb-2 text-blue-800">Visualisation&nbsp;: Projection d'embeddings</h4>
                    <div class="flex justify-center">
                        <div class="bg-gradient-to-tr from-blue-100 via-white to-purple-100 rounded-xl shadow p-4" style="min-height:200px;">
                            <svg width="320" height="180" viewBox="0 0 320 180" style="display:block;">
                                <!-- Axes -->
                                <line x1="40" y1="160" x2="300" y2="160" stroke="#94a3b8" stroke-width="1"/>
                                <line x1="40" y1="160" x2="40" y2="20" stroke="#94a3b8" stroke-width="1"/>
                                <!-- Points cluster 1 -->
                                <circle cx="80" cy="120" r="8" fill="#3b82f6" opacity="0.8"/>
                                <circle cx="90" cy="130" r="8" fill="#3b82f6" opacity="0.7"/>
                                <circle cx="85" cy="115" r="8" fill="#3b82f6" opacity="0.7"/>
                                <!-- Points cluster 2 -->
                                <circle cx="220" cy="60" r="8" fill="#a78bfa" opacity="0.8"/>
                                <circle cx="230" cy="70" r="8" fill="#a78bfa" opacity="0.7"/>
                                <circle cx="215" cy="75" r="8" fill="#a78bfa" opacity="0.7"/>
                                <!-- Points cluster 3 -->
                                <circle cx="150" cy="100" r="8" fill="#22d3ee" opacity="0.8"/>
                                <circle cx="160" cy="110" r="8" fill="#22d3ee" opacity="0.7"/>
                                <circle cx="155" cy="95" r="8" fill="#22d3ee" opacity="0.7"/>
                                <!-- Labels -->
                                <text x="60" y="110" font-size="13" fill="#1e40af" font-weight="bold">Classe A</text>
                                <text x="200" y="50" font-size="13" fill="#7c3aed" font-weight="bold">Classe B</text>
                                <text x="130" y="90" font-size="13" fill="#0891b2" font-weight="bold">Classe C</text>
                                <text x="305" y="170" font-size="11" fill="#64748b">f(x)<tspan baseline-shift="sub" font-size="9">1</tspan></text>
                                <text x="25" y="30" font-size="11" fill="#64748b">f(x)<tspan baseline-shift="sub" font-size="9">2</tspan></text>
                            </svg>
                        </div>
                    </div>
                    <p class="text-xs text-gray-600 text-center mt-2 italic">Exemple de projection 2D d'embeddings&nbsp;: les objets similaires forment des clusters dans l'espace vectoriel.</p>
                </div>
                <div class="mb-6">
                    <h4 class="font-semibold mb-2 text-blue-800">Calcul&nbsp;: Approximation de la similarité sémantique</h4>
                    <p class="text-base text-gray-700">
                        Soient deux phrases proches sémantiquement, <span class="formula">x</span> et <span class="formula">y</span>, et leurs embeddings <span class="formula">\(u = f(x) \)</span>, <span class="formula">\(v = f(y)\)</span>. Si <span class="formula">\(\text{sim}_{\cos}(u, v) \approx 0.95\)</span>, alors l'angle entre <span class="formula">u</span> et <span class="formula">v</span> est <span class="formula">\(\arccos(0.95) \approx 18^\circ\)</span>, ce qui indique une forte similarité.
                    </p>
                </div>
                <div>
                    <h4 class="font-semibold mb-2 text-blue-800">Résumé mathématique</h4>
                    <div class="formula text-center bg-blue-50 rounded-lg py-2 px-4 shadow">
                        \begin{aligned}
                            &f : X \to \mathbb{R}^d \\
                            &\text{sim}_X(x, y) \approx g(f(x), f(y)) \\
                            &\text{avec } g(u, v) = \frac{u \cdot v}{\|u\|\|v\|} \text{ (cosinus) ou } -\|u-v\| \text{ (L2)}
                        \end{aligned}
                    </div>
                </div>
            </div>
            
            <!-- 1.2 Propriétés Désirables -->
            <div id="fondements2" class="mb-12"></div>
                <h3 class="text-2xl font-bold mb-6 text-blue-700 flex items-center gap-2">
                    <span class="inline-block w-2 h-2 rounded-full bg-blue-400"></span>
                    1.2 Propriétés Désirables des Embeddings
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div class="bg-gradient-to-br from-blue-100 to-blue-50 rounded-xl shadow p-6 card border-l-4 border-blue-300">
                        <h4 class="font-semibold text-lg mb-2 text-blue-700">Conservation des relations sémantiques</h4>
                        <p class="text-base text-gray-700">Des objets similaires dans l'espace d'origine doivent être proches dans l'espace vectoriel.</p>
                    </div>
                    <div class="bg-gradient-to-br from-purple-100 to-blue-50 rounded-xl shadow p-6 card border-l-4 border-purple-300">
                        <h4 class="font-semibold text-lg mb-2 text-purple-700">Linéarité des relations</h4>
                        <p class="text-base text-gray-700">Les relations sémantiques se traduisent par des opérations vectorielles (ex: analogies).</p>
                    </div>
                    <div class="bg-gradient-to-br from-cyan-100 to-blue-50 rounded-xl shadow p-6 card border-l-4 border-cyan-300">
                        <h4 class="font-semibold text-lg mb-2 text-cyan-700">Compacité</h4>
                        <p class="text-base text-gray-700">Représentation dense et de dimension minimale.</p>
                    </div>
                    <div class="bg-gradient-to-br from-pink-100 to-blue-50 rounded-xl shadow p-6 card border-l-4 border-pink-300">
                        <h4 class="font-semibold text-lg mb-2 text-pink-700">Séparabilité</h4>
                        <p class="text-base text-gray-700">Capacité à distinguer des objets sémantiquement différents.</p>
                    </div>
                </div>
            </div>
            
            <!-- 1.3 Métriques de Distance -->
            <div id="fondements3">
                <h3 class="text-2xl font-bold mb-6 text-blue-700 flex items-center gap-2">
                    <span class="inline-block w-2 h-2 rounded-full bg-blue-400"></span>
                    1.3 Métriques de Distance et Similarité
                </h3>
                <div class="mb-8">
                    <h4 class="font-semibold text-lg mb-2 text-blue-700">Similarité Cosinus</h4>
                    <div class="formula text-center text-xl mb-2 bg-blue-50 rounded-lg py-2 px-4 shadow">
                        \[
                            \mathrm{sim}_{\cos}(u, v) = \frac{\langle u, v \rangle}{\|u\|_2 \cdot \|v\|_2}
                            = \frac{\sum_{i=1}^{d} u_i v_i}{\sqrt{\sum_{i=1}^{d} u_i^2} \sqrt{\sum_{i=1}^{d} v_i^2}}
                        \]
                    </div>
                    <p class="mt-2 text-gray-700 text-base">
                        La similarité cosinus mesure le <span class="font-semibold text-blue-700">cosinus de l'angle</span> entre deux vecteurs dans <span class="formula">\(\mathbb{R}^d\)</span>, indépendamment de leur norme. Elle varie dans <span class="formula">\([-1, 1]\)</span> et est invariante par changement d'échelle.
                    </p>
                    <div class="mt-4 flex justify-center">
                        <div class="w-full max-w-md">
                            <canvas id="cosine-similarity-chart" height="100"></canvas>
                        </div>
                    </div>
                    <div class="mt-2 text-xs text-gray-500 text-center italic"></div>
                        Illustration géométrique&nbsp;: l'angle entre deux vecteurs encode leur similarité sémantique.
                    </div>
                </div>
                <div class="mb-8">
                    <h4 class="font-semibold text-lg mb-2 text-indigo-700">Distance Euclidienne (Norme L2)</h4>
                    <div class="formula text-center text-xl mb-2 bg-indigo-50 rounded-lg py-2 px-4 shadow">
                        \[
                            d_2(u, v) = \|u - v\|_2 = \sqrt{\sum_{i=1}^{d} (u_i - v_i)^2}
                        \]
                    </div>
                    <p class="mt-2 text-gray-700 text-base">
                        La distance euclidienne quantifie la "longueur du plus court chemin" entre deux points dans l'espace vectoriel. Elle est sensible à la magnitude et à l'échelle des vecteurs.
                    </p>
                </div>
                <div class="mb-8">
                    <h4 class="font-semibold text-lg mb-2 text-cyan-700">Lien Fondamental entre Cosinus et Euclidienne</h4>
                    <p class="mb-2 text-gray-700 text-base"></p>
                        Pour des vecteurs <span class="font-semibold">normalisés</span> (<span class="formula">\(\|u\|_2 = \|v\|_2 = 1\)</span>), la distance euclidienne et la similarité cosinus sont reliées par&nbsp;:
                    </p>
                    <div class="formula text-center text-lg mb-2 bg-cyan-50 rounded-lg py-2 px-4 shadow">
                        \[
                            d_2^2(u, v) = 2(1 - \mathrm{sim}_{\cos}(u, v))
                        \]
                    </div>
                    <p class="text-xs text-gray-500 text-center italic">
                        Cette équivalence permet d'utiliser indifféremment l'une ou l'autre métrique pour des embeddings normalisés.
                    </p>
                </div>
                <div class="bg-gradient-to-br from-purple-50 to-blue-50 rounded-xl shadow-lg p-6 border-l-4 border-purple-400">
                    <h4 class="font-semibold text-lg mb-4 text-purple-700">Autres Métriques Avancées</h4>
                    <ul class="space-y-3 text-gray-700 text-base">
                        <li>
                            <span class="font-medium text-purple-700">Distance de Mahalanobis&nbsp;:</span>
                            <span class="formula bg-purple-100 px-1 rounded">
                                \( d_M(u, v) = \sqrt{(u-v)^\top \Sigma^{-1} (u-v)} \)
                            </span>
                            <span class="text-xs text-gray-500 block">Prend en compte la covariance des données, adaptée aux espaces anisotropes.</span>
                        </li>
                        <li>
                            <span class="font-medium text-purple-700">Distance de Manhattan (L1)&nbsp;:</span>
                            <span class="formula bg-purple-100 px-1 rounded">
                                \( d_1(u, v) = \sum_{i=1}^{d} |u_i - v_i| \)
                            </span>
                            <span class="text-xs text-gray-500 block">Robuste aux valeurs aberrantes, favorise la parcimonie.</span>
                        </li>
                        <li>
                            <span class="font-medium text-purple-700">Distance de Jaccard&nbsp;:</span>
                            <span class="formula bg-purple-100 px-1 rounded">
                                \( J(A, B) = \frac{|A \cap B|}{|A \cup B|} \)
                            </span>
                            <span class="text-xs text-gray-500 block">Utilisée pour des ensembles ou des vecteurs binaires (sparse).</span>
                        </li>
                        <li>
                            <span class="font-medium text-purple-700">Distance de Minkowski (généralisation)&nbsp;:</span>
                            <span class="formula bg-purple-100 px-1 rounded">
                                \( d_p(u, v) = \left( \sum_{i=1}^{d} |u_i - v_i|^p \right)^{1/p} \)
                            </span>
                            <span class="text-xs text-gray-500 block">Pour <span class="formula">\(p=1\)</span> (Manhattan), <span class="formula">\(p=2\)</span> (Euclidienne).</span>
                        </li>
                    </ul>
                </div>
            </div>
        </section>
        
        <!-- Algorithmes ANN -->
        <section id="algorithmes" class="mb-16">
            <h2 class="text-3xl font-bold mb-6 text-gray-800 border-b pb-2">2. Algorithmes de Recherche de Plus Proches Voisins Approximatifs (ANN)</h2>
            
            <!-- 2.1 Problématique -->
            <div class="mb-10">
                <h3 class="text-2xl font-semibold mb-4 text-blue-700">2.1 Problématique</h3>
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <p class="mb-4">La recherche exacte des <span class="formula">k</span> plus proches voisins parmi <span class="formula">n</span> points dans un espace de dimension <span class="formula">d</span> a une complexité naïve de <span class="formula">\(O(n \cdot d)\)</span>, ce qui devient prohibitif pour de grandes collections.</p>
                    
                    <div class="mt-6 flex justify-center">
                        <div class="w-full max-w-lg">
                            <canvas id="complexity-chart" height="853" style="display: block; box-sizing: border-box; height: 426px; width: 512px;" width="1024"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 2.2 Approches Algorithmiques -->
            <div class="mb-10" id="algorithmes2">
                <h3 class="text-2xl font-semibold mb-4 text-blue-700">2.2 Approches Algorithmiques</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <!-- Recherche Exhaustive -->
                    <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                    <!-- Recherche Exhaustive -->
                    <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                        <h4 class="font-semibold text-lg mb-2">Recherche Exhaustive (Flat, Brute-force)</h4>
                        <p class="mb-2"></p>
                            <span class="font-medium">Principe mathématique&nbsp;:</span>
                            Pour une requête <span class="formula">\(q \in \mathbb{R}^d\)</span> et une base de <span class="formula">n</span> vecteurs <span class="formula">\(\{v_1, ..., v_n\}\)</span>, on calcule la distance (ou similarité) entre <span class="formula">q</span> et chaque <span class="formula">\(v_i\)</span>:
                        </p>
                        <div class="formula text-center mb-2">
                            \(d(q, v_i), \quad \forall i \in \{1, ..., n\}\)</div>
                        <p class="mb-2"></p>
                            On sélectionne ensuite les <span class="formula">k</span> plus proches voisins&nbsp;:
                        </p>
                        <div class="formula text-center mb-4">
                            \(\text{Top-}k\left(\{d(q, v_i)\}_{i=1}^n\right)\)
                        </div>
                        <ul class="space-y-2 mb-4">
                            <li><span class="font-medium">Complexité temporelle&nbsp;:</span> <span class="formula">\(O(n \cdot d)\)</span> par requête</li>
                            <li><span class="font-medium">Précision&nbsp;:</span> 100% (résultat exact)</li>
                            <li><span class="font-medium">Mémoire&nbsp;:</span> <span class="formula">\(O(n \cdot d)\)</span> (stockage de tous les vecteurs)</li>
                        </ul>
                        <div class="mt-4 bg-blue-50 p-3 rounded-lg mb-4">
                            <p class="text-sm text-blue-800">
                                <span class="font-medium">Avantage&nbsp;:</span> Méthode conceptuellement simple, sans approximation ni structure d’index. <br>
                                <span class="font-medium">Limite&nbsp;:</span> Scalabilité très faible pour de grands <span class="formula">n</span> ou <span class="formula">d</span> (temps linéaire).
                            </p>
                        </div>
                        <div class="mt-4 flex justify-center">
                            <div class="w-full max-w-md">
                                <canvas id="brute-force-complexity-chart" height="220"></canvas>
                            </div>
                        </div>
                    </div>
                    <script>
                    document.addEventListener("DOMContentLoaded", function() {
                        const bfCtx = document.getElementById('brute-force-complexity-chart').getContext('2d');
                        new Chart(bfCtx, {
                            type: 'line',
                            data: {
                                labels: ['1K', '10K', '100K', '1M', '10M'],
                                datasets: [{
                                    label: 'Temps de calcul (O(n·d))',
                                    data: [1, 10, 100, 1000, 10000],
                                    borderColor: 'rgba(59,130,246,0.8)',
                                    backgroundColor: 'rgba(59,130,246,0.1)',
                                    borderWidth: 2,
                                    fill: true,
                                    pointRadius: 3
                                }]
                            },
                            options: {
                                scales: {
                                    y: {
                                        type: 'logarithmic',
                                        title: { display: true, text: 'Temps relatif (log)' }
                                    },
                                    x: {
                                        title: { display: true, text: 'Nombre de vecteurs (n)' }
                                    }
                                },
                                plugins: {
                                    title: {
                                        display: true,
                                        text: 'Scalabilité de la recherche exhaustive'
                                    },
                                    legend: { display: false }
                                }
                            }
                        });
                    });
                    </script>
                    </div>
                    
                    <!-- Inverted File Index -->
                    <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                        <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                        
                        <h4 class="font-semibold text-lg mb-2">Inverted File Index (IVF)</h4>
                        <p class="mb-2"><span class="font-medium">Principe mathématique&nbsp;:</span> L’espace des vecteurs est partitionné en <span class="formula">k</span> régions (ou "cellules") par clustering (souvent k-means), chaque région étant représentée par un centroïde <span class="formula">\(c_j \in \mathbb{R}^d\)</span> pour <span class="formula">\(j = 1, ..., k\)</span>.</p>
                        <div class="mb-2"></div>
                            <span class="font-medium">Indexation&nbsp;:</span>
                            <ul class="list-disc pl-6 text-sm"></ul>
                                <li>Pour chaque vecteur <span class="formula">v</span>, on assigne <span class="formula">v</span> au centroïde le plus proche&nbsp;:
                                    <div class="formula text-center">
                                        \(j^* = \arg\min_{j} \|v - c_j\|\)</div>
                                </li>
                                <li>On ne stocke que l’assignation et le résidu <span class="formula">\(r = v - c_{j^*}\)</span> (optionnel, pour quantification fine).</li>
                            </ul>
                        <div class="mb-2">
                            <span class="font-medium">Recherche (en deux étapes)&nbsp;:</span>
                            <ol class="list-decimal pl-6 mb-2 space-y-1">
                                <li>
                                    Pour une requête <span class="formula">\(q\)</span>, trouver les <span class="formula">\(n_\text{probes}\)</span> centroïdes les plus proches&nbsp;:
                                    <div class="formula text-center">
                                        \(\mathcal{C}_q = \text{Top-}n_\text{probes}\left(\arg\min_{j} \|q - c_j\|\right)\)
                                    </div>
                                </li>
                                <li>
                                    Ne comparer <span class="formula">q</span> qu’aux vecteurs assignés à ces centroïdes&nbsp;:
                                    <div class="formula text-center">
                                        \(\forall v \in \bigcup_{j \in \mathcal{C}_q} \mathcal{B}_j,\quad d(q, v)\)
                                    </div>
                                    où <span class="formula">\(\mathcal{B}_j\)</span> est la liste des vecteurs du cluster <span class="formula">\(j\)</span>.
                                </li>
                            </ol>
                        </div>
                        <div class="mb-2">
                            <span class="font-medium">Complexité théorique&nbsp;:</span>
                            <div class="formula text-center">
                                \(O\left(kd + n_\text{probes} \cdot \frac{n}{k} \cdot d\right)\)
                            </div>
                            <p class="text-sm text-gray-600 mt-1">où <span class="formula">\(k\)</span> est le nombre de clusters, <span class="formula">\(n\)</span> le nombre total de vecteurs, <span class="formula">\(d\)</span> la dimension, et <span class="formula">\(n_\text{probes}\)</span> le nombre de clusters explorés à la requête.</p>
                        </div>
                        <p><span class="font-medium">Compromis&nbsp;:</span> Plus <span class="formula">\(n_\text{probes}\)</span> est élevé, plus la recherche est précise mais lente. Pour <span class="formula">\(n_\text{probes} = k\)</span>, on retrouve la recherche exhaustive.</p>
                    </div>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- HNSW -->
                    <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                        <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                        <h4 class="font-semibold text-lg mb-2">Hierarchical Navigable Small World (HNSW)</h4>
                        <p class="mb-2"><span class="font-medium">Structure&nbsp;:</span> Graphe orienté multi-couches, chaque couche étant un graphe de type "small world" (petit monde), construit de façon hiérarchique. Les points sont répartis sur plusieurs niveaux, chaque niveau supérieur étant un sous-échantillon aléatoire du niveau inférieur.</p>
                        <p class="mb-2"><span class="font-medium">Principe de navigation&nbsp;:</span> La recherche d’un voisin proche commence au sommet (niveau le plus élevé) et procède par <span class="highlight">descente hiérarchique</span> : à chaque niveau, on effectue une recherche gloutonne (greedy) pour s’approcher du point de requête, puis on descend d’un niveau jusqu’à la base.</p>
                        <div class="mb-2">
                            <span class="font-medium">Recherche gloutonne&nbsp;: À chaque étape, on choisit le voisin</span>
                            <div class="formula text-center">
                                \(v^* = \arg\min_{v \in \mathcal{N}(u)} d(q, v)\)
                            </div>
                            <p class="text-sm text-gray-600 mt-1">où <span class="formula">\(q\)</span> est la requête, <span class="formula">\(u\)</span> le nœud courant, <span class="formula">\(\mathcal{N}(u)\)</span> ses voisins, et <span class="formula">\(d(\cdot, \cdot)\)</span> la distance choisie (L2, cosinus, etc.).</p>
                        </div>
                        <div class="mb-2">
                            <span class="font-medium">Complexité moyenne&nbsp;:</span>
                            <div class="formula text-center">
                                \(O(\log n \cdot d)\)
                            </div>
                            <p class="text-sm text-gray-600 mt-1">où <span class="formula">n</span> est le nombre de points et <span class="formula">d</span> la dimension.</p>
                        </div>
                        <p class="mb-2"><span class="font-medium">Paramètres clés&nbsp;:</span> <span class="formula">\(M\)</span> (degré max des nœuds), <span class="formula">\(efConstruction\)</span> (qualité de construction), <span class="formula">\(efSearch\)</span> (qualité de la recherche, taille du pool de candidats).</p>
                        <div class="mb-2">
                            <span class="font-medium">Résumé mathématique&nbsp;:</span>
                            <ul class="list-disc pl-6 text-sm">
                                <li>Insertion et recherche s’appuient sur la minimisation locale de la distance à la requête.</li>
                                <li>La structure hiérarchique permet d’atteindre une complexité logarithmique en nombre de points.</li>
                                <li>La qualité/rapidité dépend fortement de <span class="formula">\(efSearch\)</span> et <span class="formula">\(M\)</span>.</li>
                            </ul>
                        </div>
                        
                        <div class="mt-4 flex justify-center">
                            <div class="w-full">
                                <svg width="100%" height="150" viewBox="0 0 300 150" xmlns="http://www.w3.org/2000/svg">
                                    <!-- Layer 3 (top) -->
                                    <circle cx="150" cy="30" r="6" fill="#3b82f6"></circle>
                                    
                                    <!-- Layer 2 (middle) -->
                                    <circle cx="100" cy="70" r="6" fill="#3b82f6"></circle>
                                    <circle cx="150" cy="70" r="6" fill="#3b82f6"></circle>
                                    <circle cx="200" cy="70" r="6" fill="#3b82f6"></circle>
                                    
                                    <!-- Layer 1 (bottom) -->
                                    <circle cx="60" cy="110" r="6" fill="#3b82f6"></circle>
                                    <circle cx="100" cy="110" r="6" fill="#3b82f6"></circle>
                                    <circle cx="140" cy="110" r="6" fill="#3b82f6"></circle>
                                    <circle cx="180" cy="110" r="6" fill="#3b82f6"></circle>
                                    <circle cx="220" cy="110" r="6" fill="#3b82f6"></circle>
                                    <circle cx="260" cy="110" r="6" fill="#3b82f6"></circle>
                                    
                                    <!-- Connections -->
                                    <line x1="150" y1="30" x2="100" y2="70" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="150" y1="30" x2="150" y2="70" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="150" y1="30" x2="200" y2="70" stroke="#94a3b8" stroke-width="1"></line>
                                    
                                    <line x1="100" y1="70" x2="60" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="100" y1="70" x2="100" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="100" y1="70" x2="140" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    
                                    <line x1="150" y1="70" x2="100" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="150" y1="70" x2="140" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="150" y1="70" x2="180" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    
                                    <line x1="200" y1="70" x2="180" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="200" y1="70" x2="220" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="200" y1="70" x2="260" y2="110" stroke="#94a3b8" stroke-width="1"></line>
                                    
                                    <!-- Search path -->
                                    <line x1="150" y1="30" x2="150" y2="70" stroke="#ef4444" stroke-width="2"></line>
                                    <line x1="150" y1="70" x2="180" y2="110" stroke="#ef4444" stroke-width="2"></line>
                                    
                                    <text x="150" y="140" text-anchor="middle" fill="#1e293b" font-size="12">Structure HNSW</text>
                                </svg>
                            </div>
                        </div>
                        </div>
                    </div>
                    
                    <!-- Product Quantization -->
                    <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                        <div class="bg-white rounded-lg shadow-lg p-6 algorithm-card">
                        <h4 class="font-semibold text-lg mb-2">Product Quantization (PQ)</h4>
                        <p class="mb-2"><span class="font-medium">Principe mathématique&nbsp;:</span> L'espace des vecteurs de dimension <span class="formula">\(d\)</span> est partitionné en <span class="formula">\(m\)</span> sous-espaces orthogonaux de dimension <span class="formula">\(d' = d/m\)</span> (supposé divisible).</p>
                        <p class="mb-2"><span class="font-medium">Apprentissage&nbsp;:</span> Pour chaque sous-espace, on apprend un codebook <span class="formula">\(C_j = \{c_j[1], ..., c_j[K]\}\)</span> par k-means, où <span class="formula">\(K\)</span> est le nombre de centroïdes.</p>
                        <p class="mb-2"><span class="font-medium">Encodage&nbsp;:</span> Un vecteur <span class="formula">\(v \in \mathbb{R}^d\)</span> est découpé en <span class="formula">\(m\)</span> sous-vecteurs <span class="formula">\(v = [v_1, ..., v_m]\)</span>, puis chaque <span class="formula">\(v_j\)</span> est quantifié par l'indice <span class="formula">\(i_j = \arg\min_{i} \|v_j - c_j[i]\|\)</span>.</p>
                        <div class="mb-2">
                            <span class="font-medium">Reconstruction&nbsp;:</span>
                            <div class="formula text-center">
                                \(\tilde{v} = [c_1[i_1], c_2[i_2], ..., c_m[i_m]]\)
                            </div>
                        </div>
                        <div class="mb-2">
                            <span class="font-medium">Distance approximative (ADC)&nbsp;:</span>
                            <div class="formula text-center">
                                \(d^2(q, v) \approx \sum_{j=1}^m \|q_j - c_j[i_j]\|^2\)
                            </div>
                            <p class="text-sm text-gray-600 mt-1">Où <span class="formula">\(q\)</span> est le vecteur requête, <span class="formula">\(q_j\)</span> son <span class="formula">j</span>-ème sous-vecteur.</p>
                        </div>
                        <p class="mb-2"><span class="font-medium">Avantage&nbsp;:</span> Compression extrême (quelques octets par vecteur) et accélération de la recherche par tables de lookup pré-calculées.</p>
                        
                        <div class="mt-4 flex justify-center">
                            <div class="w-full">
                                <svg width="100%" height="150" viewBox="0 0 300 150" xmlns="http://www.w3.org/2000/svg">
                                    <!-- Original vector -->
                                    <rect x="20" y="30" width="260" height="20" fill="#e2e8f0" rx="2"></rect>
                                    <text x="150" y="25" text-anchor="middle" fill="#1e293b" font-size="12">Vecteur original (dimension d)</text>
                                    
                                    <!-- Subvectors -->
                                    <rect x="20" y="80" width="60" height="20" fill="#bfdbfe" rx="2"></rect>
                                    <rect x="90" y="80" width="60" height="20" fill="#bfdbfe" rx="2"></rect>
                                    <rect x="160" y="80" width="60" height="20" fill="#bfdbfe" rx="2"></rect>
                                    <rect x="230" y="80" width="50" height="20" fill="#bfdbfe" rx="2"></rect>
                                    
                                    <text x="150" y="75" text-anchor="middle" fill="#1e293b" font-size="12">Sous-vecteurs</text>
                                    
                                    <!-- Quantized indices -->
                                    <rect x="20" y="130" width="60" height="20" fill="#93c5fd" rx="2"></rect>
                                    <text x="50" y="144" text-anchor="middle" fill="#1e293b" font-size="12">i₁</text>
                                    
                                    <rect x="90" y="130" width="60" height="20" fill="#93c5fd" rx="2"></rect>
                                    <text x="120" y="144" text-anchor="middle" fill="#1e293b" font-size="12">i₂</text>
                                    
                                    <rect x="160" y="130" width="60" height="20" fill="#93c5fd" rx="2"></rect>
                                    <text x="190" y="144" text-anchor="middle" fill="#1e293b" font-size="12">i₃</text>
                                    
                                    <rect x="230" y="130" width="50" height="20" fill="#93c5fd" rx="2"></rect>
                                    <text x="255" y="144" text-anchor="middle" fill="#1e293b" font-size="12">i₄</text>
                                    
                                    <!-- Arrows -->
                                    <line x1="50" y1="50" x2="50" y2="80" stroke="#94a3b8" stroke-width="1" stroke-dasharray="4"></line>
                                    <line x1="120" y1="50" x2="120" y2="80" stroke="#94a3b8" stroke-width="1" stroke-dasharray="4"></line>
                                    <line x1="190" y1="50" x2="190" y2="80" stroke="#94a3b8" stroke-width="1" stroke-dasharray="4"></line>
                                    <line x1="255" y1="50" x2="255" y2="80" stroke="#94a3b8" stroke-width="1" stroke-dasharray="4"></line>
                                    
                                    <line x1="50" y1="100" x2="50" y2="130" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="120" y1="100" x2="120" y2="130" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="190" y1="100" x2="190" y2="130" stroke="#94a3b8" stroke-width="1"></line>
                                    <line x1="255" y1="100" x2="255" y2="130" stroke="#94a3b8" stroke-width="1"></line>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
                </div>
            </div>
            
            <!-- 2.3 Complexité et Curse of Dimensionality -->
            <div class="mb-10" id="algorithmes3">
                <h3 class="text-2xl font-semibold mb-4 text-blue-700">2.3 Complexité Algorithmique et Curse of Dimensionality</h3>
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <p class="mb-4">Le "fléau de la dimensionnalité" affecte sévèrement les performances des algorithmes ANN:</p>
                    
                    <ul class="list-disc pl-6 space-y-2">
                        <li>Les distances tendent à s'uniformiser en haute dimension</li>
                        <li>Les structures d'index traditionnelles (arbres) deviennent inefficaces</li>
                        <li>La notion de "voisinage" devient ambiguë</li>
                    </ul>
                    
                    <div class="mt-6 flex justify-center">
                        <div class="w-full max-w-lg">
                            <canvas id="dimensionality-chart" height="853" style="display: block; box-sizing: border-box; height: 426px; width: 512px;" width="1024"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Systèmes de Bases Vectorielles -->
        <section id="systemes" class="mb-16">
            <h2 class="text-3xl font-bold mb-6 text-gray-800 border-b pb-2">3. Systèmes de Bases Vectorielles</h2>
            
            <!-- Tabs Navigation -->
            <div class="mb-6">
                <div class="border-b border-gray-200">
                    <nav class="-mb-px flex space-x-8">
                        <button class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-blue-500 text-blue-600" data-tab="faiss">
                            Faiss
                        </button>
                        <button class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300" data-tab="milvus">
                            Milvus
                        </button>
                        <button class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300" data-tab="pinecone">
                            Pinecone
                        </button>
                    </nav>
                </div>
            </div>
            
            <!-- Faiss Tab -->
            <div id="faiss-tab" class="tab-content active">
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <div class="flex items-center mb-4">
                        <div class="w-12 h-12 flex items-center justify-center bg-blue-100 rounded-lg mr-4">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z"></path>
                            </svg>
                        </div>
                        <h3 class="text-2xl font-semibold text-blue-700">3.1 Faiss (Facebook AI Similarity Search)</h3>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                        <div>
                            <h4 class="font-semibold text-lg mb-2">Caractéristiques</h4>
                            <ul class="space-y-2">
                                <li>Développé par Facebook Research (Meta)</li>
                                <li>Implémentation C++ avec bindings Python</li>
                                <li>Optimisé pour CPU (SIMD) et GPU (CUDA)</li>
                                <li>Bibliothèque locale (non distribuée nativement)</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="font-semibold text-lg mb-2">Types d'Index</h4>
                            <ul class="space-y-2">
                                <li><span class="font-medium">IndexFlatL2:</span> Recherche exhaustive (distance L2)</li>
                                <li><span class="font-medium">IndexFlatIP:</span> Recherche exhaustive (produit scalaire)</li>
                                <li><span class="font-medium">IndexIVFFlat:</span> Index inversé avec vecteurs complets</li>
                                <li><span class="font-medium">IndexIVFPQ:</span> Index inversé avec quantification produit</li>
                                <li><span class="font-medium">IndexHNSW:</span> Graphe navigable hiérarchique</li>
                                <li><span class="font-medium">Indexes composites:</span> IndexIVFPQ, IndexIVFHNSW, etc.</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="code-container">
        <div class="code-header">
            <span>Faiss.py</span>
            <button class="copy-btn">Copier</button>
        </div>
        <pre><code class="language-python">import numpy as np
import faiss

d, n, k = 64, 10000, 5
vecs = np.random.random((n, d)).astype('float32')
q = np.random.random((1, d)).astype('float32')

index = faiss.IndexFlatL2(d)
index.add(vecs)
dist, idx = index.search(q, k)

print("Indices:", idx)
print("Distances:", dist)</code></pre>
    </div>

                        </pre>
                    </div>
                </div>
            </div>
            
            <!-- Milvus Tab -->
            <div id="milvus-tab" class="tab-content hidden" id="systemes2">
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <div class="flex items-center mb-4">
                        <div class="w-12 h-12 flex items-center justify-center bg-green-100 rounded-lg mr-4">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01"></path>
                            </svg>
                        </div>
                        <h3 class="text-2xl font-semibold text-green-700">3.2 Milvus</h3>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                        <div>
                            <h4 class="font-semibold text-lg mb-2">Caractéristiques</h4>
                            <ul class="space-y-2">
                                <li>Système distribué open-source</li>
                                <li>Architecture cloud-native (Kubernetes)</li>
                                <li>Stockage persistant des vecteurs et métadonnées</li>
                                <li>Requêtes hybrides (vectorielles + filtres)</li>
                                <li>Intégration avec écosystème big data (Pulsar, Kafka, etc.)</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="font-semibold text-lg mb-2">Architecture</h4>
                            <ul class="space-y-2">
                                <li><span class="font-medium">Coordinateur:</span> Gestion des métadonnées et coordination</li>
                                <li><span class="font-medium">Nœuds de données:</span> Stockage et recherche vectorielle</li>
                                <li><span class="font-medium">Nœuds de requête:</span> Traitement des requêtes et agrégation</li>
                                <li><span class="font-medium">Stockage:</span> Séparation stockage/calcul (S3, MinIO, etc.)</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="flex justify-center mb-6">
                        <div class="w-full max-w-2xl">
                            <svg width="100%" height="300" viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg">
                                <!-- Client Layer -->
                                <rect x="250" y="20" width="100" height="40" rx="5" fill="#d1fae5" stroke="#059669" stroke-width="2"></rect>
                                <text x="300" y="45" text-anchor="middle" fill="#059669" font-size="14">Client</text>
                                
                                <!-- Coordinator Layer -->
                                <rect x="150" y="90" width="300" height="40" rx="5" fill="#d1fae5" stroke="#059669" stroke-width="2"></rect>
                                <text x="300" y="115" text-anchor="middle" fill="#059669" font-size="14">Coordinateur</text>
                                
                                <!-- Query Nodes -->
                                <rect x="100" y="160" width="120" height="40" rx="5" fill="#d1fae5" stroke="#059669" stroke-width="2"></rect>
                                <text x="160" y="185" text-anchor="middle" fill="#059669" font-size="14">Nœuds de requête</text>
                                
                                <!-- Data Nodes -->
                                <rect x="240" y="160" width="120" height="40" rx="5" fill="#d1fae5" stroke="#059669" stroke-width="2"></rect>
                                <text x="300" y="185" text-anchor="middle" fill="#059669" font-size="14">Nœuds de données</text>
                                
                                <!-- Index Nodes -->
                                <rect x="380" y="160" width="120" height="40" rx="5" fill="#d1fae5" stroke="#059669" stroke-width="2"></rect>
                                <text x="440" y="185" text-anchor="middle" fill="#059669" font-size="14">Nœuds d'index</text>
                                
                                <!-- Storage Layer -->
                                <rect x="100" y="230" width="400" height="40" rx="5" fill="#d1fae5" stroke="#059669" stroke-width="2"></rect>
                                <text x="300" y="255" text-anchor="middle" fill="#059669" font-size="14">Stockage (S3, MinIO, etc.)</text>
                                
                                <!-- Connections -->
                                <line x1="300" y1="60" x2="300" y2="90" stroke="#059669" stroke-width="2"></line>
                                <line x1="300" y1="130" x2="300" y2="160" stroke="#059669" stroke-width="2"></line>
                                <line x1="300" y1="130" x2="160" y2="160" stroke="#059669" stroke-width="2"></line>
                                <line x1="300" y1="130" x2="440" y2="160" stroke="#059669" stroke-width="2"></line>
                                <line x1="160" y1="200" x2="160" y2="230" stroke="#059669" stroke-width="2"></line>
                                <line x1="300" y1="200" x2="300" y2="230" stroke="#059669" stroke-width="2"></line>
                                <line x1="440" y1="200" x2="440" y2="230" stroke="#059669" stroke-width="2"></line>
                            </svg>
                        </div>
                    </div>
                    <img src="./milvius.png" alt="Milvus Architecture" class="w-full max-w-2xl mx-auto mb-6" style="width: 1000px !important;  max-width: 70rem !important;">
                    
                    <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="code-container">
        <div class="code-header">
            <span>Milvus.py</span>
            <button class="copy-btn">Copier</button>
        </div>
        <pre><code class="language-python">from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType
import numpy as np

class MilvusDemo:
    def __init__(self, name="demo_collection", dim=64, host="localhost", port="19530"):
        connections.connect(host=host, port=port)
        schema = CollectionSchema([
            FieldSchema(name="id", dtype=DataType.INT64, is_primary=True),
            FieldSchema(name="embedding", dtype=DataType.FLOAT_VECTOR, dim=dim),
            FieldSchema(name="category", dtype=DataType.VARCHAR, max_length=100)
        ], description="Exemple de collection")
        self.col = Collection(name, schema)
        self.col.create_index(field_name="embedding", index_params={
            "metric_type": "L2", "index_type": "HNSW", "params": {"M": 8, "efConstruction": 64}
        })

    def insert(self, n=100):
        self.col.insert([
            list(range(n)),
            np.random.random((n, self.col.schema.fields[1].params["dim"])).astype(np.float32),
            [f"cat{i%5}" for i in range(n)]
        ])

    def search(self, limit=5, expr="category in ['cat0', 'cat1']", **kwargs):
        self.col.load()
        return self.col.search(
            [np.random.random(self.col.schema.fields[1].params["dim"]).astype(np.float32)],
            "embedding",
            {"metric_type": "L2", "params": {"ef": 16}},
            limit,
            expr,
            **kwargs
        )

demo = MilvusDemo()
demo.insert()
results = demo.search()</code></pre>
    </div>
                    </div>
                        </pre>
                    </div>
                </div>
            </div>
            
            <!-- Pinecone Tab -->
            <div id="pinecone-tab" class="tab-content hidden" id="systemes3">
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <div class="flex items-center mb-4">
                        <div class="w-12 h-12 flex items-center justify-center bg-purple-100 rounded-lg mr-4">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                            </svg>
                        </div>
                        <h3 class="text-2xl font-semibold text-purple-700">3.3 Pinecone</h3>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                        <div>
                            <h4 class="font-semibold text-lg mb-2">Caractéristiques</h4>
                            <ul class="space-y-2">
                                <li>Solution entièrement managée (SaaS)</li>
                                <li>Scaling automatique</li>
                                <li>API REST simple</li>
                                <li>Support multi-tenant</li>
                                <li>Intégration facile avec écosystèmes ML/IA</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="font-semibold text-lg mb-2">Fonctionnalités</h4>
                            <ul class="space-y-2">
                                <li>Indexation vectorielle (HNSW, IVF, etc.)</li>
                                <li>Filtrage riche sur métadonnées</li>
                                <li>Upsert (insertion/mise à jour atomique)</li>
                                <li>Requêtes par lots</li>
                                <li>Métriques et monitoring</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="bg-gray-50 p-4 rounded-lg">
    <div class="code-container">
        <div class="code-header">
            <span>Pinecone.py</span>
            <button class="copy-btn">Copier</button>
        </div>
        <pre><code class="language-python">import pinecone
import numpy as np

class PineconeIndex:
    def __init__(self, name, dim, api_key, env):
        pinecone.init(api_key=api_key, environment=env)
        if name not in pinecone.list_indexes():
            pinecone.create_index(name=name, dimension=dim, metric="cosine")
        self.idx = pinecone.Index(name)

    def upsert(self, ids, vecs, metas):
        self.idx.upsert([{"id": i, "values": v, "metadata": m} for i, v, m in zip(ids, vecs, metas)])

    def query(self, v, k=5, flt=None):
        return self.idx.query(vector=v, top_k=k, include_values=True, include_metadata=True, filter=flt)

idx = PineconeIndex("example-index", 64, "YOUR_API_KEY", "us-west1-gcp")
ids = [f"vec{i}" for i in range(100)]
vecs = np.random.random((100, 64)).tolist()
metas = [{"category": f"cat{i%5}", "score": i/100} for i in range(100)]
idx.upsert(ids, vecs, metas)
flt = {"category": {"$in": ["cat0", "cat1"]}, "score": {"$gte": 0.5}}
results = idx.query(np.random.random(64).tolist(), k=5, flt=flt)</code></pre>
    </div>
                    </div>
                </div>
            </div>
            
            <!-- Comparison Table -->
            <div class="bg-gradient-to-br from-blue-50 to-blue-100 rounded-lg shadow-lg p-6 border-l-8 border-blue-400">
                <h3 class="text-2xl font-semibold mb-4 text-gray-800">Comparaison des Systèmes</h3>
                
                <div class="overflow-x-auto">
                    <table class="min-w-full comparison-table">
                        <thead>
                            <tr class="bg-gray-100">
                                <th>Caractéristique</th>
                                <th>Faiss</th>
                                <th>Milvus</th>
                                <th>Pinecone</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Type de déploiement</td>
                                <td>Bibliothèque locale</td>
                                <td>Auto-hébergé / Cloud</td>
                                <td>SaaS (entièrement managé)</td>
                            </tr>
                            <tr>
                                <td>Scaling</td>
                                <td>Manuel</td>
                                <td>Horizontal (Kubernetes)</td>
                                <td>Automatique</td>
                            </tr>
                            <tr>
                                <td>Persistance</td>
                                <td>Non (mémoire)</td>
                                <td>Oui</td>
                                <td>Oui</td>
                            </tr>
                            <tr>
                                <td>Métadonnées</td>
                                <td>Non</td>
                                <td>Oui</td>
                                <td>Oui</td>
                            </tr>
                            <tr>
                                <td>Filtrage</td>
                                <td>Limité</td>
                                <td>Avancé</td>
                                <td>Avancé</td>
                            </tr>
                            <tr>
                                <td>Algorithmes</td>
                                <td>Nombreux (HNSW, IVF, PQ, etc.)</td>
                                <td>Plusieurs (HNSW, IVF, etc.)</td>
                                <td>Optimisé (non spécifié)</td>
                            </tr>
                            <tr>
                                <td>Cas d'usage</td>
                                <td>Recherche locale, prototypage</td>
                                <td>Applications distribuées, production</td>
                                <td>Déploiement rapide, sans infrastructure</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>
        <!-- Démo / Étude de cas -->
<!-- Démo / Étude de cas -->
<section id="demo" class="mb-16">
    <h2 class="text-3xl font-bold mb-6 text-gray-800 border-b pb-2">Moteur de Recherche Sémantique IA</h2>

    </div><!-- Moteur de recherche sémantique -->
<script>
// Base de connaissances pour la recherche sémantique
const knowledgeBase = [
  {
    title: "Introduction à Docker",
    content: "Docker est une plateforme de conteneurisation qui permet de créer, déployer et exécuter des applications dans des conteneurs. Les conteneurs sont légers, portables et autonomes.",
    tags: ["docker", "conteneur", "virtualisation", "devops"],
    url: "/docker.html",
    category: "DevOps"
  },
  {
    title: "MongoDB et le Big Data",
    content: "MongoDB est une base de données NoSQL orientée document qui offre une grande flexibilité pour le stockage et la manipulation de données volumineuses. Elle est particulièrement adaptée aux cas d'usage Big Data.",
    tags: ["mongodb", "nosql", "base de données", "big data"],
    url: "/valentin.html",
    category: "Bases de données"
  },
  {
    title: "Cassandra pour la scalabilité",
    content: "Apache Cassandra est une base de données NoSQL distribuée conçue pour gérer de grandes quantités de données sur plusieurs serveurs. Elle offre une haute disponibilité et une scalabilité linéaire.",
    tags: ["cassandra", "nosql", "base de données", "scalabilité", "big data"],
    url: "/valentin.html#cassandra",
    category: "Bases de données"
  },
  {
    title: "Hadoop et l'écosystème Big Data",
    content: "Apache Hadoop est un framework open-source pour le stockage distribué et le traitement de grands ensembles de données. Il comprend HDFS pour le stockage et MapReduce pour le traitement.",
    tags: ["hadoop", "big data", "mapreduce", "hdfs", "traitement distribué"],
    url: "/valentin.html#hadoop",
    category: "Big Data"
  },
  {
    title: "CI/CD pour bases de données",
    content: "L'intégration continue et le déploiement continu (CI/CD) pour les bases de données permettent d'automatiser les tests et les déploiements de schémas de base de données, réduisant ainsi les risques d'erreur.",
    tags: ["ci/cd", "devops", "base de données", "automatisation", "déploiement"],
    url: "/docker.html#cicd",
    category: "DevOps"
  },
  {
    title: "Infrastructure as Code",
    content: "L'Infrastructure as Code (IaC) est une approche qui consiste à gérer et provisionner l'infrastructure informatique via des fichiers de configuration plutôt que par configuration manuelle.",
    tags: ["iac", "terraform", "ansible", "devops", "automatisation"],
    url: "/docker.html#iac",
    category: "DevOps"
  },
  {
    title: "Versionnement de schéma de base de données",
    content: "Le versionnement de schéma permet de suivre et gérer les modifications apportées à la structure d'une base de données au fil du temps, facilitant ainsi les déploiements et les rollbacks.",
    tags: ["versionnement", "schéma", "base de données", "migration", "flyway", "liquibase"],
    url: "/docker.html#versionnement",
    category: "Bases de données"
  },
  {
    title: "Théorème CAP et bases de données distribuées",
    content: "Le théorème CAP stipule qu'un système distribué ne peut garantir simultanément que deux des trois propriétés suivantes : cohérence, disponibilité et tolérance au partitionnement.",
    tags: ["cap", "théorème", "base de données", "distribuée", "nosql"],
    url: "/valentin.html#architectures",
    category: "Théorie"
  },
  {
    title: "Sharding dans MongoDB",
    content: "Le sharding dans MongoDB est une méthode pour distribuer les données sur plusieurs machines. Il permet d'améliorer les performances et de gérer de grands volumes de données.",
    tags: ["mongodb", "sharding", "scalabilité", "performance", "distribution"],
    url: "/valentin.html#mongodb",
    category: "Bases de données"
  },
  {
    title: "Agrégation et pipeline dans MongoDB",
    content: "Le framework d'agrégation de MongoDB permet d'effectuer des opérations de traitement de données complexes, comme le filtrage, le groupement et le calcul de valeurs.",
    tags: ["mongodb", "agrégation", "pipeline", "traitement de données", "analytics"],
    url: "/valentin.html#mongodb-aggregation",
    category: "Bases de données"
  }
];

// Fonction pour calculer la similarité cosinus entre deux vecteurs
function cosineSimilarity(vec1, vec2) {
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  
  for (const term in vec1) {
    if (vec2[term]) {
      dotProduct += vec1[term] * vec2[term];
    }
    normA += Math.pow(vec1[term], 2);
  }
  
  for (const term in vec2) {
    normB += Math.pow(vec2[term], 2);
  }
  
  if (normA === 0 || normB === 0) return 0;
  
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

// Fonction pour créer un vecteur TF-IDF à partir d'un texte
function createTfIdfVector(text, idfScores) {
  const words = text.toLowerCase()
    .replace(/[^\w\s]/g, '')
    .split(/\s+/)
    .filter(word => word.length > 2 && !stopWords.includes(word));
  
  const termFrequency = {};
  words.forEach(word => {
    termFrequency[word] = (termFrequency[word] || 0) + 1;
  });
  
  // Normalisation TF
  const totalTerms = words.length;
  for (const term in termFrequency) {
    termFrequency[term] = termFrequency[term] / totalTerms;
  }
  
  // Application de l'IDF
  const tfIdfVector = {};
  for (const term in termFrequency) {
    if (idfScores[term]) {
      tfIdfVector[term] = termFrequency[term] * idfScores[term];
    }
  }
  
  return tfIdfVector;
}

// Liste de mots vides en français
const stopWords = [
  "le", "la", "les", "un", "une", "des", "et", "est", "sont", "pour", "dans", "par", "sur", "avec", 
  "qui", "que", "quoi", "dont", "où", "comment", "pourquoi", "quand", "ce", "cette", "ces", "mon", 
  "ton", "son", "notre", "votre", "leur", "mes", "tes", "ses", "nos", "vos", "leurs", "de", "du", 
  "au", "aux", "à", "en", "ça", "cela", "ceci", "celui", "celle", "ceux", "celles", "mais", "ou", 
  "donc", "car", "si", "ni", "ne", "pas", "plus", "moins", "très", "peu", "trop", "assez", "tout", 
  "tous", "toute", "toutes", "autre", "autres", "même", "aussi", "alors", "encore", "déjà", "toujours", 
  "jamais", "souvent", "parfois"
];

// Calcul des scores IDF pour tous les termes du corpus
function calculateIdfScores() {
  const documentCount = knowledgeBase.length;
  const termDocumentFrequency = {};
  const idfScores = {};
  
  // Compter le nombre de documents contenant chaque terme
  knowledgeBase.forEach(doc => {
    const combinedText = `${doc.title} ${doc.content} ${doc.tags.join(' ')}`.toLowerCase();
    const uniqueTerms = new Set(
      combinedText
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 2 && !stopWords.includes(word))
    );
    
    uniqueTerms.forEach(term => {
      termDocumentFrequency[term] = (termDocumentFrequency[term] || 0) + 1;
    });
  });
  
  // Calculer les scores IDF
  for (const term in termDocumentFrequency) {
    idfScores[term] = Math.log(documentCount / termDocumentFrequency[term]);
  }
  
  return idfScores;
}

// Pré-calcul des scores IDF et des vecteurs TF-IDF pour chaque document
const idfScores = calculateIdfScores();
const documentVectors = knowledgeBase.map(doc => {
  const combinedText = `${doc.title} ${doc.content} ${doc.tags.join(' ')}`;
  return createTfIdfVector(combinedText, idfScores);
});

// Fonction principale de recherche sémantique
function semanticSearch(query, topN = 5) {
  // Création du vecteur de la requête
  const queryVector = createTfIdfVector(query, idfScores);
  
  // Calcul des similarités avec chaque document
  const similarities = documentVectors.map((docVector, index) => ({
    index,
    score: cosineSimilarity(queryVector, docVector)
  }));
  
  // Tri par score de similarité décroissant
  similarities.sort((a, b) => b.score - a.score);
  
  // Retourne les N meilleurs résultats
  return similarities
    .filter(item => item.score > 0.01) // Seuil minimal de pertinence abaissé
    .slice(0, topN)
    .map(item => ({
      ...knowledgeBase[item.index],
      score: item.score
    }));
}

// Extension avec Word2Vec pour améliorer la recherche sémantique
// Modèle pré-entraîné simplifié (version démo)
const word2vecModel = {
  "docker": [0.2, 0.5, -0.3, 0.1, 0.7],
  "conteneur": [0.25, 0.48, -0.28, 0.15, 0.68],
  "mongodb": [0.6, -0.2, 0.4, 0.3, -0.1],
  "nosql": [0.58, -0.18, 0.45, 0.28, -0.15],
  "cassandra": [0.55, -0.25, 0.5, 0.2, -0.2],
  "hadoop": [0.45, -0.3, 0.6, 0.1, -0.25],
  "big": [0.4, -0.2, 0.5, 0.15, -0.1],
  "data": [0.42, -0.22, 0.48, 0.18, -0.12],
  "devops": [0.3, 0.4, -0.2, 0.2, 0.6],
  "base": [0.5, -0.1, 0.3, 0.4, -0.05],
  "données": [0.48, -0.12, 0.32, 0.38, -0.08],
  "scalabilité": [0.35, -0.15, 0.45, 0.25, 0.1],
  "performance": [0.3, -0.1, 0.4, 0.3, 0.2],
  "distribution": [0.32, -0.05, 0.38, 0.28, 0.15]
};

// Fonction pour calculer la similarité entre mots avec Word2Vec
function wordVectorSimilarity(word1, word2) {
  if (!word2vecModel[word1] || !word2vecModel[word2]) return 0;
  
  const vec1 = word2vecModel[word1];
  const vec2 = word2vecModel[word2];
  
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  
  for (let i = 0; i < vec1.length; i++) {
    dotProduct += vec1[i] * vec2[i];
    normA += Math.pow(vec1[i], 2);
    normB += Math.pow(vec2[i], 2);
  }
  
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

// Fonction pour enrichir la requête avec des termes similaires
function expandQuery(query) {
  const queryTerms = query.toLowerCase()
    .replace(/[^\w\s]/g, '')
    .split(/\s+/)
    .filter(word => word.length > 2 && !stopWords.includes(word));
  
  let expandedQuery = query;
  
  queryTerms.forEach(term => {
    if (word2vecModel[term]) {
      // Trouver les termes les plus similaires
      const similarTerms = Object.keys(word2vecModel)
        .filter(w => w !== term)
        .map(w => ({ word: w, similarity: wordVectorSimilarity(term, w) }))
        .filter(item => item.similarity > 0.8)
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, 2)
        .map(item => item.word);
      
      // Ajouter les termes similaires à la requête
      if (similarTerms.length > 0) {
        expandedQuery += " " + similarTerms.join(" ");
      }
    }
  });
  
  return expandedQuery;
}

// Fonction améliorée de recherche sémantique avec expansion de requête
function enhancedSemanticSearch(query, topN = 5) {
  const expandedQuery = expandQuery(query);
  console.log("Requête étendue:", expandedQuery);
  return semanticSearch(expandedQuery, topN);
}

// Fonction pour afficher les résultats de recherche dans l'interface
function displaySearchResults(results) {
  const resultsContainer = document.getElementById('search-results');
  resultsContainer.innerHTML = '';
  
  if (results.length === 0) {
    resultsContainer.innerHTML = '<p class="text-gray-500 py-4">Aucun résultat trouvé. Essayez d\'autres termes de recherche.</p>';
    return;
  }
  
  const resultsList = document.createElement('div');
  resultsList.className = 'space-y-4 py-4';
  
  results.forEach(result => {
    const resultItem = document.createElement('div');
    resultItem.className = 'bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow duration-300';
    
    // Formater le score en pourcentage
    const relevanceScore = Math.round(result.score * 100);
    
    resultItem.innerHTML = `
      <div class="flex justify-between items-start">
        <h3 class="text-lg font-semibold text-blue-600">
          <a href="${result.url}" class="hover:underline">${result.title}</a>
        </h3>
        <span class="bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded-full">
          ${relevanceScore}% pertinent
        </span>
      </div>
      <p class="text-gray-600 mt-1">${result.content.substring(0, 150)}${result.content.length > 150 ? '...' : ''}</p>
      <div class="mt-2 flex items-center">
        <span class="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded mr-2">${result.category}</span>
        <div class="flex flex-wrap gap-1">
          ${result.tags.slice(0, 3).map(tag => 
            `<span class="text-xs text-gray-600 bg-gray-100 px-2 py-1 rounded">${tag}</span>`
          ).join('')}
          ${result.tags.length > 3 ? `<span class="text-xs text-gray-600 px-1">+${result.tags.length - 3}</span>` : ''}
        </div>
      </div>
    `;
    
    resultsList.appendChild(resultItem);
  });
  
  resultsContainer.appendChild(resultsList);
}

// Fonction pour gérer la soumission du formulaire de recherche
function handleSearchSubmit(event) {
  event.preventDefault();
  const searchInput = document.getElementById('search-input');
  const query = searchInput.value.trim();
  
  if (query.length < 2) {
    alert('Veuillez saisir au moins 2 caractères pour la recherche.');
    return;
  }
  
  // Afficher un indicateur de chargement
  const resultsContainer = document.getElementById('search-results');
  resultsContainer.innerHTML = `
    <div class="flex justify-center items-center py-8">
      <svg class="animate-spin h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </div>
  `;
  
  // Simuler un délai pour montrer le chargement (pour l'expérience utilisateur)
  setTimeout(() => {
    // Effectuer la recherche sémantique
    const searchResults = enhancedSemanticSearch(query);
    
    // Afficher les résultats
    displaySearchResults(searchResults);
    
    // Mettre à jour l'URL avec le paramètre de recherche
    const url = new URL(window.location);
    url.searchParams.set('q', query);
    window.history.pushState({}, '', url);
    
    // Enregistrer la recherche dans l'historique local
    saveSearchToHistory(query, searchResults.length);
  }, 500);
}

// Fonction pour sauvegarder les recherches dans l'historique local
function saveSearchToHistory(query, resultCount) {
  const searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
  
  // Ajouter la nouvelle recherche
  searchHistory.unshift({
    query,
    resultCount,
    timestamp: new Date().toISOString()
  });
  
  // Limiter l'historique à 10 entrées
  if (searchHistory.length > 10) {
    searchHistory.pop();
  }
  
  // Sauvegarder l'historique mis à jour
  localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
  
  // Mettre à jour l'affichage de l'historique si nécessaire
  updateSearchHistoryDisplay();
}

// Fonction pour afficher l'historique des recherches
function updateSearchHistoryDisplay() {
  const historyContainer = document.getElementById('search-history');
  if (!historyContainer) return;
  
  const searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
  
  if (searchHistory.length === 0) {
    historyContainer.innerHTML = '<p class="text-sm text-gray-500">Aucun historique de recherche</p>';
    return;
  }
  
  const historyList = document.createElement('ul');
  historyList.className = 'space-y-1';
  
  searchHistory.forEach(item => {
    const historyItem = document.createElement('li');
    historyItem.className = 'text-sm';
    
    // Formater la date
    const searchDate = new Date(item.timestamp);
    const formattedDate = searchDate.toLocaleDateString('fr-FR', {
      day: '2-digit',
      month: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
    
    historyItem.innerHTML = `
      <button class="text-blue-600 hover:underline" onclick="searchFromHistory('${item.query}')">
        ${item.query}
      </button>
      <span class="text-gray-500 text-xs">(${item.resultCount} résultat${item.resultCount !== 1 ? 's' : ''} - ${formattedDate})</span>
    `;
    
    historyList.appendChild(historyItem);
  });
  
  historyContainer.innerHTML = '';
  historyContainer.appendChild(historyList);
}

// Fonction pour effectuer une recherche depuis l'historique
function searchFromHistory(query) {
  const searchInput = document.getElementById('search-input');
  searchInput.value = query;
  
  // Déclencher la recherche
  const searchForm = document.getElementById('search-form');
  searchForm.dispatchEvent(new Event('submit'));
  
  // Faire défiler jusqu'aux résultats
  document.getElementById('search-results').scrollIntoView({ behavior: 'smooth' });
}

// Fonction pour suggérer des termes de recherche pendant la saisie
function provideSuggestions(input) {
  const query = input.value.trim().toLowerCase();
  if (query.length < 2) {
    hideSuggestions();
    return;
  }
  
  // Extraire tous les termes uniques de la base de connaissances
  const allTerms = new Set();
  knowledgeBase.forEach(doc => {
    const terms = `${doc.title} ${doc.content} ${doc.tags.join(' ')}`.toLowerCase()
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 2 && !stopWords.includes(word));
    
    terms.forEach(term => allTerms.add(term));
  });
  
  // Filtrer les termes qui correspondent à la saisie
  const matchingTerms = Array.from(allTerms)
    .filter(term => term.includes(query))
    .sort()
    .slice(0, 5);
  
  // Ajouter les titres qui correspondent
  const matchingTitles = knowledgeBase
    .filter(doc => doc.title.toLowerCase().includes(query))
    .map(doc => doc.title)
    .slice(0, 3);
  
  // Combiner et dédupliquer les suggestions
  const suggestions = [...new Set([...matchingTitles, ...matchingTerms])].slice(0, 5);
  
  displaySuggestions(suggestions);
}

// Fonction pour afficher les suggestions
function displaySuggestions(suggestions) {
  const suggestionsContainer = document.getElementById('search-suggestions');
  
  if (suggestions.length === 0) {
    hideSuggestions();
    return;
  }
  
  suggestionsContainer.innerHTML = '';
  
  suggestions.forEach(suggestion => {
    const suggestionItem = document.createElement('div');
    suggestionItem.className = 'px-4 py-2 hover:bg-gray-100 cursor-pointer';
    suggestionItem.textContent = suggestion;
    suggestionItem.onclick = () => {
      document.getElementById('search-input').value = suggestion;
      hideSuggestions();
      document.getElementById('search-form').dispatchEvent(new Event('submit'));
    };
    
    suggestionsContainer.appendChild(suggestionItem);
  });
  
  suggestionsContainer.classList.remove('hidden');
}

// Fonction pour masquer les suggestions
function hideSuggestions() {
  const suggestionsContainer = document.getElementById('search-suggestions');
  suggestionsContainer.classList.add('hidden');
}

// Fonction pour analyser les tendances de recherche
function analyzeSearchTrends() {
  const searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
  
  if (searchHistory.length < 3) {
    return null; // Pas assez de données pour l'analyse
  }
  
  // Extraire tous les termes de recherche
  const allSearchTerms = searchHistory
    .map(item => item.query.toLowerCase()
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 2 && !stopWords.includes(word))
    )
    .flat();
  
  // Compter la fréquence des termes
  const termFrequency = {};
  allSearchTerms.forEach(term => {
    termFrequency[term] = (termFrequency[term] || 0) + 1;
  });
  
  // Trier par fréquence
  const sortedTerms = Object.entries(termFrequency)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([term, count]) => ({ term, count }));
  
  return sortedTerms;
}

// Fonction pour suggérer des sujets populaires basés sur l'historique
function suggestPopularTopics() {
  const trends = analyzeSearchTrends();
  const suggestionsContainer = document.getElementById('popular-topics');
  
  if (!suggestionsContainer || !trends || trends.length === 0) return;
  
  suggestionsContainer.innerHTML = '<h3 class="text-sm font-medium text-gray-700 mb-2">Sujets populaires :</h3>';
  
  const topicsList = document.createElement('div');
  topicsList.className = 'flex flex-wrap gap-2';
  
  trends.forEach(({ term }) => {
    const topicButton = document.createElement('button');
    topicButton.className = 'bg-blue-50 hover:bg-blue-100 text-blue-700 text-xs px-2 py-1 rounded-full transition-colors';
    topicButton.textContent = term;
    topicButton.onclick = () => {
      document.getElementById('search-input').value = term;
      document.getElementById('search-form').dispatchEvent(new Event('submit'));
    };
    
    topicsList.appendChild(topicButton);
  });
  
  suggestionsContainer.appendChild(topicsList);
}

// Initialisation du moteur de recherche
document.addEventListener('DOMContentLoaded', () => {
  const searchForm = document.getElementById('search-form');
  const searchInput = document.getElementById('search-input');
  
  if (searchForm && searchInput) {
    // Gestionnaire de soumission du formulaire
    searchForm.addEventListener('submit', handleSearchSubmit);
    
    // Gestionnaire de saisie pour les suggestions
    searchInput.addEventListener('input', () => provideSuggestions(searchInput));
    
    // Cliquer en dehors des suggestions les masque
    document.addEventListener('click', (event) => {
      if (!event.target.closest('#search-suggestions') && !event.target.closest('#search-input')) {
        hideSuggestions();
      }
    });
    
    // Vérifier si une recherche est présente dans l'URL
    const urlParams = new URLSearchParams(window.location.search);
    const queryParam = urlParams.get('q');
    
    if (queryParam) {
      searchInput.value = queryParam;
      searchForm.dispatchEvent(new Event('submit'));
    }
    
    // Mettre à jour l'historique des recherches
    updateSearchHistoryDisplay();
    
    // Suggérer des sujets populaires
    suggestPopularTopics();
  }
});
</script>

<div class="bg-white shadow-md rounded-lg p-6 mb-8">
  
  <form id="search-form" class="mb-6">
    <div class="relative">
      <div class="flex">
        <input 
          id="search-input" 
          type="text" 
          placeholder="Rechercher des concepts, technologies, exemples..." 
          class="w-full px-4 py-3 border border-gray-300 rounded-l-lg focus:ring-blue-500 focus:border-blue-500"
          autocomplete="off"
        >
        <button 
          type="submit" 
          class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-r-lg transition-colors"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
        </button>
      </div>
      
      <div id="search-suggestions" class="absolute z-10 w-full bg-white border border-gray-300 rounded-lg mt-1 shadow-lg hidden">
        <!-- Les suggestions seront ajoutées ici dynamiquement -->
      </div>
    </div>
    
    <div class="flex justify-between items-center mt-3">
      <div id="popular-topics" class="text-sm">
        <!-- Les sujets populaires seront ajoutés ici dynamiquement -->
      </div>
      
      <div class="flex items-center">
        <span class="text-sm text-gray-600 mr-2">Recherche alimentée par :</span>
        <span class="bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded">TF-IDF</span>
        <span class="bg-purple-100 text-purple-800 text-xs font-semibold px-2.5 py-0.5 rounded ml-1">Word2Vec</span>
        <span class="bg-green-100 text-green-800 text-xs font-semibold px-2.5 py-0.5 rounded ml-1">Cosine Similarity</span>
      </div>
    </div>
  </form>
  
  <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
    <div class="md:col-span-3">
      <div id="search-results" class="min-h-[200px]">
        <div class="flex flex-col items-center justify-center h-full py-8 text-center">
          <svg class="w-16 h-16 text-gray-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
          <h3 class="text-xl font-medium text-gray-700 mb-2">Recherche sémantique</h3>
          <p class="text-gray-500 max-w-md">
            Utilisez notre moteur de recherche sémantique pour trouver des informations pertinentes sur les bases de données, le Big Data, Docker et plus encore.
          </p>
        </div>
      </div>
    </div>
    
    <div class="bg-gray-50 p-4 rounded-lg">
      <h3 class="text-lg font-semibold text-gray-800 mb-3">Historique de recherche</h3>
      <div id="search-history" class="mb-6">
        <p class="text-sm text-gray-500">Aucun historique de recherche</p>
      </div>
      
      <h3 class="text-lg font-semibold text-gray-800 mb-3">Comment ça marche</h3>
      <div class="text-sm text-gray-600 space-y-2">
        <p>Un simple moteur de recherche sémantique (flemme de faire plus) pour traitement du langage naturel :</p>
        <ul class="list-disc pl-5 space-y-1">
          <li>Vectorisation TF-IDF des documents</li>
          <li>Expansion de requête avec Word2Vec</li>
          <li>Similarité cosinus pour le classement</li>
          <li>Filtrage des mots vides</li>
        </ul>
        <p class="mt-3">Cela permet de trouver des résultats pertinents même si les termes exacts ne correspondent pas.</p>
      </div>
      
      <div class="mt-6 pt-4 border-t border-gray-200">
        <button 
          onclick="localStorage.removeItem('searchHistory'); updateSearchHistoryDisplay(); return false;" 
          class="text-sm text-red-600 hover:text-red-800"
        >
          Effacer l'historique
        </button>
      </div>
    </div>
  </div>
</div>


<!-- Intégration de Chart.js pour les visualisations -->
<script>
// Fonction pour générer un graphique des tendances de recherche
function generateSearchTrendsChart() {
  const searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
  
  if (searchHistory.length < 5) {
    document.getElementById('search-trends-visualization').classList.add('hidden');
    return;
  }
  
  document.getElementById('search-trends-visualization').classList.remove('hidden');
  
  // Extraire les données pour le graphique
  const last10Searches = searchHistory.slice(0, 10).reverse();
  const labels = last10Searches.map(item => {
    const date = new Date(item.timestamp);
    return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
  });
  
  const data = last10Searches.map(item => item.resultCount);
  
  // Créer le graphique avec Chart.js
  const ctx = document.getElementById('trends-chart').getContext('2d');
  new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'Nombre de résultats',
        data: data,
        backgroundColor: 'rgba(59, 130, 246, 0.2)',
        borderColor: 'rgba(59, 130, 246, 1)',
        borderWidth: 2,
        tension: 0.3,
        pointBackgroundColor: 'rgba(59, 130, 246, 1)',
        pointRadius: 4,
        pointHoverRadius: 6
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Nombre de résultats'
          },
          ticks: {
            precision: 0
          }
        },
        x: {
          title: {
            display: true,
            text: 'Heure de recherche'
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          position: 'top'
        },
        tooltip: {
          callbacks: {
            title: function(tooltipItems) {
              const index = tooltipItems[0].dataIndex;
              return `Recherche: ${last10Searches[index].query}`;
            }
          }
        }
      }
    }
  });
}

// Fonction pour améliorer les résultats avec des données externes
async function enrichSearchResults(results) {
  // Cette fonction simule l'enrichissement des résultats avec des données externes
  // Dans une implémentation réelle, vous pourriez appeler une API externe
  
  // Simuler un appel API asynchrone
  return new Promise(resolve => {
    setTimeout(() => {
      // Enrichir chaque résultat avec des informations supplémentaires
      const enrichedResults = results.map(result => {
        // Ajouter des métadonnées supplémentaires
        return {
          ...result,
          lastUpdated: new Date().toISOString(),
          viewCount: Math.floor(Math.random() * 1000) + 50,
          relatedTopics: getRelatedTopics(result.tags)
        };
      });
      
      resolve(enrichedResults);
    }, 300);
  });
}

// Fonction pour obtenir des sujets connexes basés sur les tags
function getRelatedTopics(tags) {
  // Mapping des relations entre sujets
  const topicRelations = {
    "docker": ["conteneur", "kubernetes", "devops"],
    "mongodb": ["nosql", "json", "atlas"],
    "cassandra": ["nosql", "scalabilité", "distribution"],
    "hadoop": ["mapreduce", "hdfs", "spark"],
    "big data": ["analytics", "data lake", "spark"],
    "nosql": ["mongodb", "cassandra", "couchbase"],
    "devops": ["ci/cd", "docker", "kubernetes"],
    "base de données": ["sql", "nosql", "migration"]
  };
  
  // Collecter les sujets connexes pour tous les tags
  const relatedSet = new Set();
  tags.forEach(tag => {
    if (topicRelations[tag]) {
      topicRelations[tag].forEach(related => relatedSet.add(related));
    }
  });
  
  // Supprimer les tags déjà présents
  tags.forEach(tag => relatedSet.delete(tag));
  
  // Convertir en tableau et limiter à 3 sujets
  return Array.from(relatedSet).slice(0, 3);
}

// Fonction pour afficher des résultats enrichis
async function displayEnrichedResults(results) {
  // Enrichir les résultats avec des données externes
  const enrichedResults = await enrichSearchResults(results);
  
  // Afficher les résultats enrichis
  displaySearchResults(enrichedResults);
  
  // Ajouter des informations supplémentaires pour chaque résultat
  const resultElements = document.querySelectorAll('#search-results > div > div');
  
  enrichedResults.forEach((result, index) => {
    if (index < resultElements.length) {
      const element = resultElements[index];
      
      // Ajouter des informations de métadonnées
      const metadataDiv = document.createElement('div');
      metadataDiv.className = 'mt-2 text-xs text-gray-500 flex items-center justify-between';
      
      // Formater la date de dernière mise à jour
      const lastUpdated = new Date(result.lastUpdated);
      const formattedDate = lastUpdated.toLocaleDateString('fr-FR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
      });
      
      metadataDiv.innerHTML = `
        <span>Mis à jour le ${formattedDate}</span>
        <span>${result.viewCount} vues</span>
      `;
      
      element.appendChild(metadataDiv);
      
      // Ajouter des sujets connexes s'ils existent
      if (result.relatedTopics && result.relatedTopics.length > 0) {
        const relatedTopicsDiv = document.createElement('div');
        relatedTopicsDiv.className = 'mt-3 pt-2 border-t border-gray-100';
        
        relatedTopicsDiv.innerHTML = `
          <span class="text-xs text-gray-600">Sujets connexes : </span>
          <div class="flex flex-wrap gap-1 mt-1">
            ${result.relatedTopics.map(topic => 
              `<button onclick="searchFromHistory('${topic}')" class="text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 px-2 py-1 rounded transition-colors">${topic}</button>`
            ).join('')}
          </div>
        `;
        
        element.appendChild(relatedTopicsDiv);
      }
    }
  });
}

// Remplacer la fonction handleSearchSubmit pour utiliser les résultats enrichis
function handleSearchSubmit(event) {
  event.preventDefault();
  const searchInput = document.getElementById('search-input');
  const query = searchInput.value.trim();
  
  if (query.length < 2) {
    alert('Veuillez saisir au moins 2 caractères pour la recherche.');
    return;
  }
  
  // Afficher un indicateur de chargement
  const resultsContainer = document.getElementById('search-results');
  resultsContainer.innerHTML = `
    <div class="flex justify-center items-center py-8">
      <svg class="animate-spin h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </div>
  `;
  
  // Simuler un délai pour montrer le chargement (pour l'expérience utilisateur)
  setTimeout(async () => {
    // Effectuer la recherche sémantique
    const searchResults = enhancedSemanticSearch(query);
    
    // Afficher les résultats enrichis
    await displayEnrichedResults(searchResults);
    
    // Mettre à jour l'URL avec le paramètre de recherche
    const url = new URL(window.location);
    url.searchParams.set('q', query);
    window.history.pushState({}, '', url);
    
    // Enregistrer la recherche dans l'historique local
    saveSearchToHistory(query, searchResults.length);
    
    // Mettre à jour le graphique des tendances
    generateSearchTrendsChart();
  }, 500);
}

// Initialisation du moteur de recherche (version mise à jour)
document.addEventListener('DOMContentLoaded', () => {
  const searchForm = document.getElementById('search-form');
  const searchInput = document.getElementById('search-input');
  
  if (searchForm && searchInput) {
    // Gestionnaire de soumission du formulaire
    searchForm.addEventListener('submit', handleSearchSubmit);
    
    // Gestionnaire de saisie pour les suggestions
    searchInput.addEventListener('input', () => provideSuggestions(searchInput));
    
    // Cliquer en dehors des suggestions les masque
    document.addEventListener('click', (event) => {
      if (!event.target.closest('#search-suggestions') && !event.target.closest('#search-input')) {
        hideSuggestions();
      }
    });
    
    // Vérifier si une recherche est présente dans l'URL
    const urlParams = new URLSearchParams(window.location.search);
    const queryParam = urlParams.get('q');
    
    if (queryParam) {
      searchInput.value = queryParam;
      searchForm.dispatchEvent(new Event('submit'));
    }
    
    // Mettre à jour l'historique des recherches
    updateSearchHistoryDisplay();
    
    // Suggérer des sujets populaires
    suggestPopularTopics();
    
    // Générer le graphique des tendances
    generateSearchTrendsChart();
  }
});
</script>

<!-- Intégration de Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    
            <script>
                /**
 * Démo de recherche vectorielle - Implémentation des concepts de bases vectorielles
 */

class VectorSearchDemo {
    constructor() {
        this.documents = [];
        this.embeddings = {};
        this.indexes = {};
        this.dimension = 128;
        this.initialized = false;
        
        // Éléments DOM
        this.docListEl = document.getElementById('doc-list');
        this.resultsEl = document.getElementById('results');
        this.searchForm = document.getElementById('search-form');
        this.queryInput = document.getElementById('query-input');
        this.algorithmSelect = document.getElementById('algorithm-select');
        this.metricSelect = document.getElementById('metric-select');
        this.topKInput = document.getElementById('top-k');
        this.dimensionSelect = document.getElementById('dimension-select');
        this.filterTagsInput = document.getElementById('filter-tags');
        this.searchTimeEl = document.getElementById('search-time');
        this.searchStatsEl = document.getElementById('search-stats');
        this.corpusStatsEl = document.getElementById('corpus-stats');
        
        // Canvas pour visualisation
        this.canvas = document.getElementById('embedding-visualization');
        this.ctx = this.canvas.getContext('2d');
        
        // Initialisation
        this.init();
    }
    
    async init() {
        try {
            // Charger les documents
            await this.loadDocuments();
            
            // Générer les embeddings
            this.generateEmbeddings();
            
            // Créer les index
            this.createIndexes();
            
            // Afficher les documents
            this.renderDocumentList();
            
            // Ajouter les écouteurs d'événements
            this.setupEventListeners();
            
            this.initialized = true;
            console.log('Démo initialisée avec succès');
        } catch (error) {
            console.error('Erreur lors de l\'initialisation:', error);
        }
    }
    
    async loadDocuments() {
        // Dans une application réelle, cela chargerait depuis le serveur
        // Pour cette démo, nous utilisons les données intégrées
        this.documents = [
            {
                "id": "doc1",
                "title": "Introduction à l'apprentissage profond et aux réseaux de neurones",
                "content": "L'apprentissage profond est un sous-domaine de l'apprentissage automatique qui utilise des réseaux de neurones à plusieurs couches pour modéliser des abstractions de haut niveau dans les données. Ces réseaux de neurones sont composés de couches successives de neurones artificiels qui transforment les données d'entrée en représentations de plus en plus abstraites.",
                "tags": ["deep learning", "neural networks", "AI"]
            },
            {
                "id": "doc2",
                "title": "Recherche sémantique avec embeddings de texte",
                "content": "La recherche sémantique utilise des embeddings vectoriels pour capturer le sens des mots et des phrases au-delà de la simple correspondance de mots-clés. Ces embeddings sont générés par des modèles de langage pré-entraînés qui transforment le texte en vecteurs de haute dimension où la similarité cosinus reflète la proximité sémantique.",
                "tags": ["semantic search", "embeddings", "NLP"]
            },
            {
                "id": "doc3",
                "title": "Clustering de données en haute dimension",
                "content": "Le clustering en haute dimension pose des défis particuliers en raison du fléau de la dimensionnalité. Des algorithmes comme K-means, DBSCAN et les méthodes hiérarchiques doivent être adaptés pour fonctionner efficacement dans ces espaces où les distances tendent à s'uniformiser.",
                                "tags": ["clustering", "high-dimensional data", "dimensionality curse"]
            },
            {
                "id": "doc4",
                "title": "Bases vectorielles pour la recherche documentaire",
                "content": "Les bases de données vectorielles sont optimisées pour stocker et rechercher des vecteurs d'embeddings. Elles utilisent des algorithmes de recherche approximative des plus proches voisins (ANN) comme HNSW, IVF et PQ pour accélérer les requêtes sur de grands ensembles de données.",
                "tags": ["vector databases", "ANN", "information retrieval"]
            },
            {
                "id": "doc5",
                "title": "Applications de l'IA générative",
                "content": "L'IA générative, notamment les modèles comme GPT, DALL-E et Stable Diffusion, peut créer du contenu original comme du texte, des images et de la musique. Ces systèmes s'appuient sur des architectures de transformers et des techniques d'apprentissage par renforcement à partir de feedback humain.",
                "tags": ["generative AI", "GPT", "content generation"]
            },
            {
                "id": "doc6",
                "title": "Algorithmes HNSW pour la recherche de similarité",
                "content": "Hierarchical Navigable Small World (HNSW) est un algorithme de pointe pour la recherche approximative des plus proches voisins. Il construit un graphe multi-couches où chaque couche est un graphe 'petit monde', permettant une navigation efficace avec une complexité logarithmique.",
                "tags": ["HNSW", "ANN", "similarity search"]
            },
            {
                "id": "doc7",
                "title": "Quantification produit pour la compression de vecteurs",
                "content": "La quantification produit (PQ) divise les vecteurs en sous-vecteurs qui sont quantifiés séparément. Cette technique permet de compresser significativement les embeddings tout en préservant la capacité à calculer des distances approximatives, réduisant ainsi les besoins en mémoire.",
                "tags": ["product quantization", "vector compression", "ANN"]
            },
            {
                "id": "doc8",
                "title": "Métriques de distance pour les embeddings",
                "content": "Le choix de la métrique de distance est crucial pour les systèmes d'embeddings. La similarité cosinus est invariante à l'échelle mais sensible à l'angle, tandis que la distance euclidienne prend en compte la magnitude. D'autres métriques comme Manhattan ou Mahalanobis ont leurs propres caractéristiques.",
                "tags": ["distance metrics", "cosine similarity", "euclidean distance"]
            }
        ];
        
        // Mettre à jour les statistiques du corpus
        this.updateCorpusStats();
    }
    
    updateCorpusStats() {
        this.corpusStatsEl.textContent = `${this.documents.length} documents, ${this.dimension} dimensions`;
    }
    
    generateEmbeddings() {
        // Récupérer la dimension sélectionnée
        this.dimension = parseInt(this.dimensionSelect.value);
        
        // Générer des embeddings pour chaque document
        // Dans une application réelle, cela utiliserait un modèle de langage
        this.documents.forEach(doc => {
            this.embeddings[doc.id] = this.generateFakeEmbedding(doc.title + " " + doc.content, this.dimension);
        });
        
        console.log(`Embeddings générés avec dimension ${this.dimension}`);
    }
    
    generateFakeEmbedding(text, dimension) {
        // Fonction qui génère un embedding simulé mais déterministe basé sur le texte
        // Dans une application réelle, on utiliserait un modèle comme BERT, USE, etc.
        const hash = this.hashString(text);
        const embedding = new Array(dimension).fill(0);
        
        // Générer un vecteur basé sur le hash du texte
        for (let i = 0; i < dimension; i++) {
            // Utiliser des fonctions trigonométriques pour générer des valeurs entre -1 et 1
            embedding[i] = Math.sin(hash * (i + 1) * 0.01) + Math.cos(hash * (i + 0.5) * 0.01);
        }
        
        // Normaliser le vecteur (norme L2 = 1)
        return this.normalizeVector(embedding);
    }
    
    hashString(str) {
        // Fonction de hachage simple pour générer une valeur numérique à partir d'une chaîne
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Conversion en entier 32 bits
        }
        return Math.abs(hash);
    }
    
    normalizeVector(vector) {
        // Normalisation L2 du vecteur
        const norm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        return vector.map(val => val / norm);
    }
    
    createIndexes() {
        // Créer différents types d'index pour la recherche
        
        // 1. Index exhaustif (force brute)
        this.indexes.exhaustive = {
            search: (query, k, metric) => this.exhaustiveSearch(query, k, metric)
        };
        
        // 2. Index HNSW simulé
        this.indexes.hnsw = {
            // Simuler la structure HNSW
            layers: this.createHNSWLayers(),
            search: (query, k, metric) => this.hnswSearch(query, k, metric)
        };
        
        // 3. Index inversé (IVF) simulé
        this.indexes.ivf = {
            // Simuler la structure IVF avec 4 clusters
            clusters: this.createIVFClusters(4),
            search: (query, k, metric) => this.ivfSearch(query, k, metric)
        };
        
        console.log("Indexes créés");
    }
    
    createHNSWLayers() {
        // Simulation simplifiée de la structure HNSW
        // Dans une implémentation réelle, cela construirait un graphe multi-couches
        
        // Créer des connexions entre documents similaires
        const layers = [];
        const numLayers = 3; // Nombre de couches dans le graphe
        
        for (let layer = 0; layer < numLayers; layer++) {
            const connections = {};
            const layerDocs = layer === 0 
                ? Object.keys(this.embeddings) 
                : Object.keys(this.embeddings).filter(() => Math.random() < 0.5);
            
            layerDocs.forEach(docId => {
                // Pour chaque document, trouver ses voisins les plus proches
                const neighbors = this.findNearestNeighbors(docId, 3, 'cosine', layerDocs);
                connections[docId] = neighbors.map(n => n.id);
            });
            
            layers.push(connections);
        }
        
        return layers;
    }
    
    createIVFClusters(numClusters) {
        // Simulation simplifiée de l'index inversé
        // Dans une implémentation réelle, cela utiliserait k-means
        
        // Initialiser les clusters avec des centroïdes aléatoires
        const clusters = [];
        const docIds = Object.keys(this.embeddings);
        
        for (let i = 0; i < numClusters; i++) {
            // Choisir un document aléatoire comme centroïde initial
            const centroidId = docIds[Math.floor(Math.random() * docIds.length)];
            clusters.push({
                centroidId,
                centroid: this.embeddings[centroidId],
                members: []
            });
        }
        
        // Assigner chaque document au cluster le plus proche
        docIds.forEach(docId => {
            const embedding = this.embeddings[docId];
            let bestCluster = 0;
            let bestDistance = Infinity;
            
            clusters.forEach((cluster, idx) => {
                const distance = this.calculateDistance(embedding, cluster.centroid, 'euclidean');
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestCluster = idx;
                }
            });
            
            clusters[bestCluster].members.push(docId);
        });
        
        return clusters;
    }
    
    findNearestNeighbors(docId, k, metric, candidateIds = null) {
        const query = this.embeddings[docId];
        const candidates = candidateIds || Object.keys(this.embeddings).filter(id => id !== docId);
        
        return candidates.map(id => ({
            id,
            distance: this.calculateDistance(query, this.embeddings[id], metric)
        }))
        .sort((a, b) => {
            // Pour la similarité cosinus, plus grand = meilleur
            // Pour les autres métriques, plus petit = meilleur
            return metric === 'cosine' ? b.distance - a.distance : a.distance - b.distance;
        })
        .slice(0, k);
    }
    
    exhaustiveSearch(query, k, metric) {
        console.time('exhaustiveSearch');
        
        // Recherche par force brute: comparer avec tous les documents
        const results = Object.keys(this.embeddings).map(docId => ({
            id: docId,
            distance: this.calculateDistance(query, this.embeddings[docId], metric)
        }))
        .sort((a, b) => {
            // Pour la similarité cosinus, plus grand = meilleur
            // Pour les autres métriques, plus petit = meilleur
            return metric === 'cosine' ? b.distance - a.distance : a.distance - b.distance;
        })
        .slice(0, k);
        
        console.timeEnd('exhaustiveSearch');
        return results;
    }
    
    hnswSearch(query, k, metric) {
        console.time('hnswSearch');
        
        // Simulation simplifiée de la recherche HNSW
        // Dans une implémentation réelle, cela naviguerait dans le graphe
        
        // Commencer par la couche supérieure
        let candidates = new Set();
        const layers = this.indexes.hnsw.layers;
        
        // Ajouter quelques documents aléatoires comme points d'entrée
        const entryPoints = Object.keys(layers[layers.length - 1]).slice(0, 2);
        entryPoints.forEach(ep => candidates.add(ep));
        
        // Parcourir les couches de haut en bas
        for (let layer = layers.length - 1; layer >= 0; layer--) {
            const connections = layers[layer];
            const newCandidates = new Set();
            
            // Pour chaque candidat actuel, explorer ses voisins
            candidates.forEach(docId => {
                if (connections[docId]) {
                    connections[docId].forEach(neighbor => newCandidates.add(neighbor));
                }
            });
            
            // Ajouter les nouveaux candidats
            newCandidates.forEach(c => candidates.add(c));
            
            // Si nous sommes à la couche inférieure, limiter le nombre de candidats
            if (layer === 0 && candidates.size > 20) {
                // Garder seulement les 20 meilleurs candidats
                const bestCandidates = Array.from(candidates)
                    .map(id => ({
                        id,
                        distance: this.calculateDistance(query, this.embeddings[id], metric)
                    }))
                    .sort((a, b) => {
                        return metric === 'cosine' ? b.distance - a.distance : a.distance - b.distance;
                    })
                    .slice(0, 20);
                
                candidates = new Set(bestCandidates.map(c => c.id));
            }
        }
        
        // Calculer les distances finales et trier
        const results = Array.from(candidates)
            .map(docId => ({
                id: docId,
                distance: this.calculateDistance(query, this.embeddings[docId], metric)
            }))
            .sort((a, b) => {
                return metric === 'cosine' ? b.distance - a.distance : a.distance - b.distance;
            })
            .slice(0, k);
        
        console.timeEnd('hnswSearch');
        return results;
    }
    
    ivfSearch(query, k, metric) {
        console.time('ivfSearch');
        
        // Simulation simplifiée de la recherche IVF
        // Dans une implémentation réelle, cela utiliserait des structures plus optimisées
        
        const clusters = this.indexes.ivf.clusters;
        
        // Trouver les clusters les plus proches de la requête
        const clusterDistances = clusters.map((cluster, idx) => ({
            idx,
            distance: this.calculateDistance(query, cluster.centroid, metric)
        }))
        .sort((a, b) => {
            return metric === 'cosine' ? b.distance - a.distance : a.distance - b.distance;
        });
        
        // Sélectionner les 2 clusters les plus proches (ou 50% des clusters)
        const numClustersToSearch = Math.max(1, Math.ceil(clusters.length * 0.5));
        const selectedClusters = clusterDistances.slice(0, numClustersToSearch);
        
        // Collecter tous les documents des clusters sélectionnés
        let candidates = [];
        selectedClusters.forEach(cluster => {
            candidates = candidates.concat(clusters[cluster.idx].members);
        });
        
        // Calculer les distances et trier
        const results = candidates
            .map(docId => ({
                id: docId,
                distance: this.calculateDistance(query, this.embeddings[docId], metric)
            }))
            .sort((a, b) => {
                return metric === 'cosine' ? b.distance - a.distance : a.distance - b.distance;
            })
            .slice(0, k);
        
        console.timeEnd('ivfSearch');
        return results;
    }
    
    calculateDistance(vec1, vec2, metric) {
        if (metric === 'cosine') {
            // Similarité cosinus
            let dotProduct = 0;
            for (let i = 0; i < vec1.length; i++) {
                dotProduct += vec1[i] * vec2[i];
            }
            return dotProduct; // Les vecteurs sont déjà normalisés
        } else if (metric === 'euclidean') {
            // Distance euclidienne
            let sum = 0;
            for (let i = 0; i < vec1.length; i++) {
                const diff = vec1[i] - vec2[i];
                sum += diff * diff;
            }
            return Math.sqrt(sum);
                    } else if (metric === 'dot') {
            // Produit scalaire
            let dotProduct = 0;
            for (let i = 0; i < vec1.length; i++) {
                dotProduct += vec1[i] * vec2[i];
            }
            return dotProduct;
        }
        
        // Par défaut, retourner la similarité cosinus
        return this.calculateDistance(vec1, vec2, 'cosine');
    }
    
    renderDocumentList() {
        // Afficher la liste des documents
        this.docListEl.innerHTML = '';
        
        this.documents.forEach(doc => {
            const li = document.createElement('li');
            li.innerHTML = `
                <div class="mb-1">
                    <span class="font-medium">${doc.title}</span>
                </div>
                <div class="text-xs text-gray-600 mb-1">${doc.content.substring(0, 100)}...</div>
                <div class="flex flex-wrap gap-1">
                    ${doc.tags.map(tag => `<span class="bg-blue-100 text-blue-800 text-xs px-2 py-0.5 rounded">${tag}</span>`).join('')}
                </div>
            `;
            this.docListEl.appendChild(li);
        });
    }
    
    visualizeEmbeddings() {
        // Visualiser les embeddings en 2D en utilisant une projection simplifiée
        // Dans une application réelle, on utiliserait t-SNE ou UMAP
        
        // Redimensionner le canvas
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
        
        // Effacer le canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Projeter les embeddings en 2D (projection simplifiée)
        const projections = {};
        const docIds = Object.keys(this.embeddings);
        
        // Calculer les projections
        docIds.forEach(docId => {
            const embedding = this.embeddings[docId];
            // Utiliser les deux premières composantes comme coordonnées x,y
            // Dans une application réelle, on utiliserait PCA, t-SNE ou UMAP
            projections[docId] = this.projectEmbedding(embedding);
        });
        
        // Normaliser les coordonnées pour s'adapter au canvas
        const allX = Object.values(projections).map(p => p.x);
        const allY = Object.values(projections).map(p => p.y);
        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        const minY = Math.min(...allY);
        const maxY = Math.max(...allY);
        
        const padding = 40;
        const scaleX = (this.canvas.width - 2 * padding) / (maxX - minX || 1);
        const scaleY = (this.canvas.height - 2 * padding) / (maxY - minY || 1);
        
        // Dessiner les points
        docIds.forEach((docId, index) => {
            const doc = this.documents.find(d => d.id === docId);
            const proj = projections[docId];
            
            const x = padding + (proj.x - minX) * scaleX;
            const y = padding + (proj.y - minY) * scaleY;
            
            // Dessiner le point
            this.ctx.beginPath();
            this.ctx.arc(x, y, 8, 0, 2 * Math.PI);
            
            // Couleur basée sur les tags du document
            const hue = (this.hashString(doc.tags.join('')) % 360);
            this.ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            this.ctx.fill();
            
            // Ajouter une bordure
            this.ctx.strokeStyle = `hsl(${hue}, 70%, 40%)`;
            this.ctx.lineWidth = 1;
            this.ctx.stroke();
            
            // Ajouter un label
            this.ctx.fillStyle = '#1e293b';
            this.ctx.font = '10px Inter, sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(doc.id, x, y - 12);
        });
    }
    
    projectEmbedding(embedding) {
        // Projection simplifiée d'un embedding en 2D
        // Dans une application réelle, on utiliserait t-SNE ou UMAP
        
        // Utiliser une projection linéaire simple basée sur des sommes pondérées
        let x = 0, y = 0;
        
        for (let i = 0; i < embedding.length; i++) {
            if (i % 2 === 0) {
                x += embedding[i] * Math.cos(i * 0.1);
            } else {
                y += embedding[i] * Math.sin(i * 0.1);
            }
        }
        
        return { x, y };
    }
    
    setupEventListeners() {
        // Écouteur pour le formulaire de recherche
        this.searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.performSearch();
        });
        
        // Écouteur pour le changement de dimension
        this.dimensionSelect.addEventListener('change', () => {
            this.dimension = parseInt(this.dimensionSelect.value);
            this.generateEmbeddings();
            this.createIndexes();
            this.updateCorpusStats();
        });
    
    }
    
    performSearch() {
        const query = this.queryInput.value.trim();
        if (!query) return;
        
        // Afficher les statistiques de recherche
        this.searchStatsEl.classList.remove('hidden');
        
        // Récupérer les paramètres
        const algorithm = this.algorithmSelect.value;
        const metric = this.metricSelect.value;
        const topK = parseInt(this.topKInput.value);
        const filterTags = this.filterTagsInput.value.trim().toLowerCase().split(/\s*,\s*/);
        
        // Générer l'embedding de la requête
        const queryEmbedding = this.generateFakeEmbedding(query, this.dimension);
        
        // Mesurer le temps de recherche
        const startTime = performance.now();
        
        // Effectuer la recherche avec l'algorithme sélectionné
        let results = this.indexes[algorithm].search(queryEmbedding, topK, metric);
        
        // Appliquer le filtre de tags si nécessaire
        if (filterTags.length > 0 && filterTags[0] !== '') {
            results = results.filter(result => {
                const doc = this.documents.find(d => d.id === result.id);
                return filterTags.some(tag => doc.tags.some(t => t.toLowerCase().includes(tag)));
            });
        }
        
        const endTime = performance.now();
        const searchTime = (endTime - startTime).toFixed(2);
        
        // Afficher le temps de recherche
        this.searchTimeEl.textContent = searchTime;
        
        // Afficher les résultats
        this.renderSearchResults(results);
        
        // Mettre en évidence les résultats dans la visualisation
        this.highlightSearchResults(results);
    }
    
    renderSearchResults(results) {
        this.resultsEl.innerHTML = '';
        
        if (results.length === 0) {
            this.resultsEl.innerHTML = '<div class="text-gray-500">Aucun résultat trouvé</div>';
            return;
        }
        
        results.forEach(result => {
            const doc = this.documents.find(d => d.id === result.id);
            const resultEl = document.createElement('div');
            resultEl.className = 'bg-blue-50 rounded-lg p-3 mb-2';
            
            // Formater la distance/similarité
            let scoreText = '';
            const metric = this.metricSelect.value;
            if (metric === 'cosine') {
                scoreText = `Similarité: ${result.distance.toFixed(3)}`;
            } else if (metric === 'euclidean') {
                scoreText = `Distance: ${result.distance.toFixed(3)}`;
            } else {
                scoreText = `Score: ${result.distance.toFixed(3)}`;
            }
            
            resultEl.innerHTML = `
                <div class="font-semibold text-blue-800">${doc.title}</div>
                <div class="text-sm text-gray-700 mb-1">${doc.content.substring(0, 150)}...</div>
                <div class="flex justify-between items-center">
                    <div class="flex flex-wrap gap-1">
                        ${doc.tags.map(tag => `<span class="bg-blue-200 text-blue-800 text-xs px-2 py-0.5 rounded">${tag}</span>`).join('')}
                    </div>
                    <div class="text-xs text-blue-600 font-medium">${scoreText}</div>
                </div>
            `;
            
            this.resultsEl.appendChild(resultEl);
        });
    }
    
    highlightSearchResults(results) {
        // Mettre à jour la visualisation pour mettre en évidence les résultats
        
        // Dessiner des cercles autour des résultats
        const docIds = results.map(r => r.id);
        const allX = [];
        const allY = [];
        
        // Projeter les embeddings en 2D
        const projections = {};
        docIds.forEach(docId => {
            const embedding = this.embeddings[docId];
            projections[docId] = this.projectEmbedding(embedding);
        });
        
        // Normaliser les coordonnées
        Object.values(projections).forEach(p => {
            allX.push(p.x);
            allY.push(p.y);
        });
        
        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        const minY = Math.min(...allY);
        const maxY = Math.max(...allY);
        
        const padding = 40;
        const scaleX = (this.canvas.width - 2 * padding) / (maxX - minX || 1);
        const scaleY = (this.canvas.height - 2 * padding) / (maxY - minY || 1);
        
        // Dessiner des cercles autour des résultats
        docIds.forEach((docId, index) => {
            const proj = projections[docId];
            
            const x = padding + (proj.x - minX) * scaleX;
            const y = padding + (proj.y - minY) * scaleY;
            
            // Dessiner un cercle autour du point
            this.ctx.beginPath();
            this.ctx.arc(x, y, 12, 0, 2 * Math.PI);
            this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            
            // Ajouter un numéro de rang
            this.ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
            this.ctx.font = 'bold 10px Inter, sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`#${index + 1}`, x, y + 20);
        });
    }
}

// Initialiser la démo lorsque le DOM est chargé
document.addEventListener('DOMContentLoaded', () => {
    const demo = new VectorSearchDemo();
});
/**
 * Simulation d'une base de données vectorielle NoSQL
 * Cette classe implémente une base de données vectorielle simple basée sur des fichiers
 */
class VectorDB {
    constructor(options = {}) {
        this.collections = {};
        this.indexes = {};
        this.options = {
            persistToLocalStorage: true,
            ...options
        };
        
        // Charger les données depuis le localStorage si disponible
        this.loadFromStorage();
    }
    
    // Créer une nouvelle collection
    createCollection(name, schema = {}) {
        if (this.collections[name]) {
            throw new Error(`Collection ${name} existe déjà`);
        }
        
        this.collections[name] = {
            name,
            schema,
            documents: [],
            vectorField: schema.vectorField || 'vector',
            idField: schema.idField || 'id'
        };
        
        // Sauvegarder l'état
        this.saveToStorage();
        
        return this.collections[name];
    }
    
    // Insérer des documents dans une collection
    insert(collectionName, documents) {
        const collection = this.collections[collectionName];
        if (!collection) {
            throw new Error(`Collection ${collectionName} n'existe pas`);
        }
        
        // Vérifier que chaque document a un ID unique
        documents.forEach(doc => {
            if (!doc[collection.idField]) {
                throw new Error(`Document sans ${collection.idField}`);
            }
            
            // Vérifier que l'ID n'existe pas déjà
            const exists = collection.documents.some(d => d[collection.idField] === doc[collection.idField]);
            if (exists) {
                throw new Error(`Document avec ${collection.idField}=${doc[collection.idField]} existe déjà`);
            }
            
            // Vérifier que le document a un vecteur si requis
            if (collection.vectorField && !doc[collection.vectorField]) {
                throw new Error(`Document sans ${collection.vectorField}`);
            }
        });
        
        // Ajouter les documents
        collection.documents.push(...documents);
        
        // Invalider les index
        if (this.indexes[collectionName]) {
            this.indexes[collectionName].isValid = false;
        }
        
        // Sauvegarder l'état
        this.saveToStorage();
        
        return documents.length;
    }
    
    // Créer un index pour la recherche vectorielle
    createIndex(collectionName, options = {}) {
        const collection = this.collections[collectionName];
        if (!collection) {
            throw new Error(`Collection ${collectionName} n'existe pas`);
        }
        
        const indexOptions = {
            type: options.type || 'hnsw',
            vectorField: options.vectorField || collection.vectorField,
            metricType: options.metricType || 'cosine',
            ...options
        };
        
        // Créer l'index
        this.indexes[collectionName] = {
            options: indexOptions,
            isValid: false
        };
        
        // Construire l'index en fonction du type
        this.buildIndex(collectionName);
        
        // Sauvegarder l'état
        this.saveToStorage();
        
        return this.indexes[collectionName];
    }
    
    // Construire l'index pour une collection
    buildIndex(collectionName) {
        const collection = this.collections[collectionName];
        const index = this.indexes[collectionName];
        
        if (!collection || !index) {
            throw new Error(`Collection ou index ${collectionName} n'existe pas`);
        }
        
        const { type, vectorField, metricType } = index.options;
        
        // Construire l'index en fonction du type
        if (type === 'hnsw') {
            // Simuler un index HNSW
            index.data = this.buildHNSWIndex(collection, vectorField, metricType);
        } else if (type === 'ivf') {
            // Simuler un index IVF
            index.data = this.buildIVFIndex(collection, vectorField, metricType);
        } else if (type === 'flat') {
            // Index plat (recherche exhaustive)
            index.data = { type: 'flat' };
        } else {
            throw new Error(`Type d'index non supporté: ${type}`);
        }
        
        index.isValid = true;
    }
    
    // Construire un index HNSW
    buildHNSWIndex(collection, vectorField, metricType) {
        console.log(`Construction d'un index HNSW pour ${collection.name}`);
        
        // Dans une implémentation réelle, cela construirait un graphe multi-couches
        // Pour cette démo, nous simulons une structure simplifiée
        
        const documents = collection.documents;
        const layers = [];
        const numLayers = 3; // Nombre de couches dans le graphe
        
        for (let layer = 0; layer < numLayers; layer++) {
            const connections = {};
            const layerDocs = layer === 0 
                ? documents 
                : documents.filter(() => Math.random() < 0.5);
            
            layerDocs.forEach(doc => {
                const docId = doc[collection.idField];
                // Pour chaque document, trouver ses voisins les plus proches
                const neighbors = this.findNearestNeighbors(
                    collection, 
                    doc[vectorField], 
                    3, // M paramètre de HNSW
                    metricType, 
                    layerDocs.map(d => d[collection.idField]),
                    docId
                );
                connections[docId] = neighbors.map(n => n.id);
            });
            
            layers.push(connections);
        }
        
        return { type: 'hnsw', layers };
    }
    
    // Construire un index IVF
    buildIVFIndex(collection, vectorField, metricType) {
        console.log(`Construction d'un index IVF pour ${collection.name}`);
        
        // Dans une implémentation réelle, cela utiliserait k-means
        // Pour cette démo, nous simulons une structure simplifiée
        
        const documents = collection.documents;
        const numClusters = Math.min(4, Math.ceil(documents.length / 2));
        
        // Initialiser les clusters avec des centroïdes aléatoires
        const clusters = [];
        
        for (let i = 0; i < numClusters; i++) {
            // Choisir un document aléatoire comme centroïde initial
            const centroidDoc = documents[Math.floor(Math.random() * documents.length)];
            clusters.push({
                centroidId: centroidDoc[collection.idField],
                centroid: centroidDoc[vectorField],
                members: []
            });
        }
        
        // Assigner chaque document au cluster le plus proche
        documents.forEach(doc => {
            const docId = doc[collection.idField];
            const vector = doc[vectorField];
            let bestCluster = 0;
            let bestDistance = Infinity;
            
            clusters.forEach((cluster, idx) => {
                const distance = this.calculateDistance(vector, cluster.centroid, metricType);
                // Pour la similarité cosinus, plus grand = meilleur
                const isCloser = metricType === 'cosine' 
                    ? distance > bestDistance 
                    : distance < bestDistance;
                
                if (isCloser) {
                    bestDistance = distance;
                    bestCluster = idx;
                }
            });
            
            clusters[bestCluster].members.push(docId);
        });
        
        return { type: 'ivf', clusters };
    }
    
    // Trouver les k plus proches voisins
    findNearestNeighbors(collection, queryVector, k, metricType, candidateIds, excludeId = null) {
        const candidates = candidateIds 
            ? collection.documents.filter(d => candidateIds.includes(d[collection.idField]))
            : collection.documents;
        
        return candidates
            .filter(doc => doc[collection.idField] !== excludeId)
            .map(doc => ({
                id: doc[collection.idField],
                distance: this.calculateDistance(queryVector, doc[collection.vectorField], metricType)
            }))
            .sort((a, b) => {
                // Pour la similarité cosinus, plus grand = meilleur
                return metricType === 'cosine' 
                    ? b.distance - a.distance 
                    : a.distance - b.distance;
            })
            .slice(0, k);
    }
    
    // Calculer la distance/similarité entre deux vecteurs
    calculateDistance(vec1, vec2, metricType) {
        if (metricType === 'cosine') {
            // Similarité cosinus
            let dotProduct = 0;
            let norm1 = 0;
            let norm2 = 0;
            
            for (let i = 0; i < vec1.length; i++) {
                dotProduct += vec1[i] * vec2[i];
                norm1 += vec1[i] * vec1[i];
                norm2 += vec2[i] * vec2[i];
            }
            
            return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
        } else if (metricType === 'euclidean') {
            // Distance euclidienne
            let sum = 0;
            for (let i = 0; i < vec1.length; i++) {
                const diff = vec1[i] - vec2[i];
                sum += diff * diff;
            }
            return Math.sqrt(sum);
        } else if (metricType === 'dot') {
            // Produit scalaire
            let dotProduct = 0;
            for (let i = 0; i < vec1.length; i++) {
                dotProduct += vec1[i] * vec2[i];
            }
            return dotProduct;
        }
        
        throw new Error(`Métrique non supportée: ${metricType}`);
    }
    
    // Rechercher des documents similaires
    search(collectionName, queryVector, k = 10, options = {}) {
        const collection = this.collections[collectionName];
        if (!collection) {
            throw new Error(`Collection ${collectionName} n'existe pas`);
        }
        
        const searchOptions = {
            metricType: 'cosine',
            filter: null,
            ...options
        };
        
        // Vérifier si un index existe
        const index = this.indexes[collectionName];
        
        // Si l'index n'est pas valide, le reconstruire
        if (index && !index.isValid) {
            this.buildIndex(collectionName);
        }
        
        // Effectuer la recherche en fonction du type d'index
        let results;
        
        if (index && index.data.type === 'hnsw') {
            results = this.searchHNSW(collection, index, queryVector, k, searchOptions);
        } else if (index && index.data.type === 'ivf') {
            results = this.searchIVF(collection, index, queryVector, k, searchOptions);
        } else {
            // Recherche exhaustive
            results = this.searchExhaustive(collection, queryVector, k, searchOptions);
        }
        
        // Appliquer le filtre si nécessaire
        if (searchOptions.filter) {
            results = this.applyFilter(collection, results, searchOptions.filter);
        }
        
        return results;
    }
    
    // Recherche exhaustive
    searchExhaustive(collection, queryVector, k, options) {
        console.time('searchExhaustive');
        
        const { metricType } = options;
        const vectorField = collection.vectorField;
        
        // Calculer la distance pour tous les documents
        const results = collection.documents.map(doc => ({
            id: doc[collection.idField],
            distance: this.calculateDistance(queryVector, doc[vectorField], metricType),
            document: doc
        }))
        .sort((a, b) => {
            // Pour la similarité cosinus, plus grand = meilleur
            return metricType === 'cosine' 
                ? b.distance - a.distance 
                : a.distance - b.distance;
        })
        .slice(0, k);
        
        console.timeEnd('searchExhaustive');
        return results;
    }
    
    // Recherche avec HNSW
    searchHNSW(collection, index, queryVector, k, options) {
        console.time('searchHNSW');
        
        const { metricType } = options;
        const vectorField = collection.vectorField;
        const layers = index.data.layers;
        
        // Simulation simplifiée de la recherche HNSW
        // Dans une implémentation réelle, cela naviguerait dans le graphe
        
        // Commencer par la couche supérieure
        let candidates = new Set();
        
        // Ajouter quelques documents aléatoires comme points d'entrée
        const entryPoints = Object.keys(layers[layers.length - 1]).slice(0, 2);
        entryPoints.forEach(ep => candidates.add(ep));
        
        // Parcourir les couches de haut en bas
        for (let layer = layers.length - 1; layer >= 0; layer--) {
            const connections = layers[layer];
            const newCandidates = new Set();
            
            // Pour chaque candidat actuel, explorer ses voisins
            candidates.forEach(docId => {
                if (connections[docId]) {
                    connections[docId].forEach(neighbor => newCandidates.add(neighbor));
                }
            });
            
            // Ajouter les nouveaux candidats
            newCandidates.forEach(c => candidates.add(c));
            
            // Si nous sommes à la couche inférieure, limiter le nombre de candidats
            if (layer === 0 && candidates.size > 20) {
                // Garder seulement les 20 meilleurs candidats
                const bestCandidates = Array.from(candidates)
                    .map(id => {
                        const doc = collection.documents.find(d => d[collection.idField] === id);
                        return {
                            id,
                            distance: this.calculateDistance(queryVector, doc[vectorField], metricType)
                        };
                    })
                    .sort((a, b) => {
                        return metricType === 'cosine' 
                            ? b.distance - a.distance 
                            : a.distance - b.distance;
                    })
                    .slice(0, 20);
                
                candidates = new Set(bestCandidates.map(c => c.id));
            }
        }
        
        // Calculer les distances finales et trier
        const results = Array.from(candidates)
            .map(id => {
                const doc = collection.documents.find(d => d[collection.idField] === id);
                return {
                    id,
                    distance: this.calculateDistance(queryVector, doc[vectorField], metricType),
                    document: doc
                };
            })
            .sort((a, b) => {
                return metricType === 'cosine' 
                    ? b.distance - a.distance 
                    : a.distance - b.distance;
            })
            .slice(0, k);
        
        console.timeEnd('searchHNSW');
        return results;
    }
    
    // Recherche avec IVF
    searchIVF(collection, index, queryVector, k, options) {
        console.time('searchIVF');
        
        const { metricType } = options;
        const vectorField = collection.vectorField;
        const clusters = index.data.clusters;
        
        // Trouver les clusters les plus proches de la requête
        const clusterDistances = clusters.map((cluster, idx) => ({
            idx,
            distance: this.calculateDistance(queryVector, cluster.centroid, metricType)
        }))
        .sort((a, b) => {
            return metricType === 'cosine' 
                ? b.distance - a.distance 
                : a.distance - b.distance;
        });
        
        // Sélectionner les 2 clusters les plus proches (ou 50% des clusters)
        const numClustersToSearch = Math.max(1, Math.ceil(clusters.length * 0.5));
        const selectedClusters = clusterDistances.slice(0, numClustersToSearch);
        
        // Collecter tous les documents des clusters sélectionnés
        let candidateIds = [];
        selectedClusters.forEach(cluster => {
            candidateIds = candidateIds.concat(clusters[cluster.idx].members);
        });
        
        // Calculer les distances et trier
        const results = candidateIds
            .map(id => {
                const doc = collection.documents.find(d => d[collection.idField] === id);
                return {
                    id,
                    distance: this.calculateDistance(queryVector, doc[vectorField], metricType),
                    document: doc
                };
            })
            .sort((a, b) => {
                return metricType === 'cosine' 
                    ? b.distance - a.distance 
                    : a.distance - b.distance;
            })
            .slice(0, k);
        
        console.timeEnd('searchIVF');
        return results;
    }
    
    // Appliquer un filtre aux résultats
    applyFilter(collection, results, filter) {
        // Fonction simple pour appliquer un filtre
        return results.filter(result => {
            const doc = result.document;
            
            // Vérifier chaque condition du filtre
            for (const [field, condition] of Object.entries(filter)) {
                if (typeof condition === 'object') {
                    // Opérateurs de comparaison
                    if ('$eq' in condition && doc[field] !== condition.$eq) return false;
                    if ('$ne' in condition && doc[field] === condition.$ne) return false;
                                        if ('$gt' in condition && doc[field] <= condition.$gt) return false;
                    if ('$gte' in condition && doc[field] < condition.$gte) return false;
                    if ('$lt' in condition && doc[field] >= condition.$lt) return false;
                    if ('$lte' in condition && doc[field] > condition.$lte) return false;
                    if ('$in' in condition && !condition.$in.includes(doc[field])) return false;
                    if ('$nin' in condition && condition.$nin.includes(doc[field])) return false;
                    
                    // Opérateurs pour les tableaux
                    if ('$contains' in condition) {
                        const value = condition.$contains;
                        if (!Array.isArray(doc[field]) || !doc[field].includes(value)) return false;
                    }
                    if ('$containsAny' in condition) {
                        const values = condition.$containsAny;
                        if (!Array.isArray(doc[field]) || !values.some(v => doc[field].includes(v))) return false;
                    }
                    if ('$containsAll' in condition) {
                        const values = condition.$containsAll;
                        if (!Array.isArray(doc[field]) || !values.every(v => doc[field].includes(v))) return false;
                    }
                } else {
                    // Égalité simple
                    if (doc[field] !== condition) return false;
                }
            }
            
            return true;
        });
    }
    
    // Sauvegarder l'état dans le localStorage
    saveToStorage() {
        if (!this.options.persistToLocalStorage) return;
        
        try {
            // Créer une version sérialisable des collections
            const serializableCollections = {};
            for (const [name, collection] of Object.entries(this.collections)) {
                serializableCollections[name] = {
                    name: collection.name,
                    schema: collection.schema,
                    documents: collection.documents,
                    vectorField: collection.vectorField,
                    idField: collection.idField
                };
            }
            
            // Sauvegarder les collections
            localStorage.setItem('vectordb_collections', JSON.stringify(serializableCollections));
            
            // Sauvegarder les options des index (pas les données d'index)
            const serializableIndexes = {};
            for (const [name, index] of Object.entries(this.indexes)) {
                serializableIndexes[name] = {
                    options: index.options,
                    isValid: false // Forcer la reconstruction des index au chargement
                };
            }
            
            localStorage.setItem('vectordb_indexes', JSON.stringify(serializableIndexes));
        } catch (error) {
            console.error('Erreur lors de la sauvegarde dans localStorage:', error);
        }
    }
    
    // Charger l'état depuis le localStorage
    loadFromStorage() {
        if (!this.options.persistToLocalStorage) return;
        
        try {
            // Charger les collections
            const collectionsJson = localStorage.getItem('vectordb_collections');
            if (collectionsJson) {
                this.collections = JSON.parse(collectionsJson);
            }
            
            // Charger les options des index
            const indexesJson = localStorage.getItem('vectordb_indexes');
            if (indexesJson) {
                this.indexes = JSON.parse(indexesJson);
            }
        } catch (error) {
            console.error('Erreur lors du chargement depuis localStorage:', error);
        }
    }
    
    // Effacer toutes les données
    clear() {
        this.collections = {};
        this.indexes = {};
        
        if (this.options.persistToLocalStorage) {
            localStorage.removeItem('vectordb_collections');
            localStorage.removeItem('vectordb_indexes');
        }
    }
}

// Exporter la classe pour utilisation
window.VectorDB = VectorDB;
/**
 * Initialisation de la base de données vectorielle avec des données de test
 */
document.addEventListener('DOMContentLoaded', () => {
    // Créer une instance de la base de données
    const db = new VectorDB();
    
    // Effacer les données existantes
    db.clear();
    
    // Créer une collection pour les documents
    db.createCollection('documents', {
        vectorField: 'embedding',
        idField: 'id'
    });
    
    // Générer des embeddings pour les documents
    const documents = [
        {
            id: "doc1",
            title: "Introduction à l'apprentissage profond et aux réseaux de neurones",
            content: "L'apprentissage profond est un sous-domaine de l'apprentissage automatique qui utilise des réseaux de neurones à plusieurs couches pour modéliser des abstractions de haut niveau dans les données. Ces réseaux de neurones sont composés de couches successives de neurones artificiels qui transforment les données d'entrée en représentations de plus en plus abstraites.",
            tags: ["deep learning", "neural networks", "AI"]
        },
        {
            id: "doc2",
            title: "Recherche sémantique avec embeddings de texte",
            content: "La recherche sémantique utilise des embeddings vectoriels pour capturer le sens des mots et des phrases au-delà de la simple correspondance de mots-clés. Ces embeddings sont générés par des modèles de langage pré-entraînés qui transforment le texte en vecteurs de haute dimension où la similarité cosinus reflète la proximité sémantique.",
            tags: ["semantic search", "embeddings", "NLP"]
        },
        {
            id: "doc3",
            title: "Clustering de données en haute dimension",
            content: "Le clustering en haute dimension pose des défis particuliers en raison du fléau de la dimensionnalité. Des algorithmes comme K-means, DBSCAN et les méthodes hiérarchiques doivent être adaptés pour fonctionner efficacement dans ces espaces où les distances tendent à s'uniformiser.",
            tags: ["clustering", "high-dimensional data", "dimensionality curse"]
        },
        {
            id: "doc4",
            title: "Bases vectorielles pour la recherche documentaire",
            content: "Les bases de données vectorielles sont optimisées pour stocker et rechercher des vecteurs d'embeddings. Elles utilisent des algorithmes de recherche approximative des plus proches voisins (ANN) comme HNSW, IVF et PQ pour accélérer les requêtes sur de grands ensembles de données.",
            tags: ["vector databases", "ANN", "information retrieval"]
        },
        {
            id: "doc5",
            title: "Applications de l'IA générative",
            content: "L'IA générative, notamment les modèles comme GPT, DALL-E et Stable Diffusion, peut créer du contenu original comme du texte, des images et de la musique. Ces systèmes s'appuient sur des architectures de transformers et des techniques d'apprentissage par renforcement à partir de feedback humain.",
            tags: ["generative AI", "GPT", "content generation"]
        },
        {
            id: "doc6",
            title: "Algorithmes HNSW pour la recherche de similarité",
            content: "Hierarchical Navigable Small World (HNSW) est un algorithme de pointe pour la recherche approximative des plus proches voisins. Il construit un graphe multi-couches où chaque couche est un graphe 'petit monde', permettant une navigation efficace avec une complexité logarithmique.",
            tags: ["HNSW", "ANN", "similarity search"]
        },
        {
            id: "doc7",
            title: "Quantification produit pour la compression de vecteurs",
            content: "La quantification produit (PQ) divise les vecteurs en sous-vecteurs qui sont quantifiés séparément. Cette technique permet de compresser significativement les embeddings tout en préservant la capacité à calculer des distances approximatives, réduisant ainsi les besoins en mémoire.",
            tags: ["product quantization", "vector compression", "ANN"]
        },
        {
            id: "doc8",
            title: "Métriques de distance pour les embeddings",
            content: "Le choix de la métrique de distance est crucial pour les systèmes d'embeddings. La similarité cosinus est invariante à l'échelle mais sensible à l'angle, tandis que la distance euclidienne prend en compte la magnitude. D'autres métriques comme Manhattan ou Mahalanobis ont leurs propres caractéristiques.",
            tags: ["distance metrics", "cosine similarity", "euclidean distance"]
        }
    ];
    
    // Générer des embeddings pour chaque document
    const dimension = 128;
    documents.forEach(doc => {
        doc.embedding = generateFakeEmbedding(doc.title + " " + doc.content, dimension);
    });
    
    // Insérer les documents dans la collection
    db.insert('documents', documents);
    
    // Créer différents types d'index
    db.createIndex('documents', { type: 'flat', metricType: 'cosine' });
    db.createIndex('documents', { type: 'hnsw', metricType: 'cosine' });
    db.createIndex('documents', { type: 'ivf', metricType: 'cosine' });
    
    console.log('Base de données initialisée avec des données de test');
    
    // Exposer la base de données globalement pour les tests dans la console
    window.db = db;
    
    // Fonction pour générer un embedding simulé
    function generateFakeEmbedding(text, dimension) {
        // Fonction qui génère un embedding simulé mais déterministe basé sur le texte
        const hash = hashString(text);
        const embedding = new Array(dimension).fill(0);
        
        // Générer un vecteur basé sur le hash du texte
        for (let i = 0; i < dimension; i++) {
            embedding[i] = Math.sin(hash * (i + 1) * 0.01) + Math.cos(hash * (i + 0.5) * 0.01);
        }
        
        // Normaliser le vecteur (norme L2 = 1)
        return normalizeVector(embedding);
    }
    
    function hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }
    
    function normalizeVector(vector) {
        const norm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        return vector.map(val => val / norm);
    }
});
/**
 * Démo de recherche vectorielle utilisant la base de données NoSQL
 */
class VectorSearchDemoDB {
    constructor() {
        // Éléments DOM
        this.docListEl = document.getElementById('doc-list');
        this.resultsEl = document.getElementById('results');
        this.searchForm = document.getElementById('search-form');
        this.queryInput = document.getElementById('query-input');
        this.algorithmSelect = document.getElementById('algorithm-select');
        this.metricSelect = document.getElementById('metric-select');
        this.topKInput = document.getElementById('top-k');
        this.dimensionSelect = document.getElementById('dimension-select');
        this.filterTagsInput = document.getElementById('filter-tags');
        this.searchTimeEl = document.getElementById('search-time');
        this.searchStatsEl = document.getElementById('search-stats');
        this.corpusStatsEl = document.getElementById('corpus-stats');
        
        // Canvas pour visualisation
        this.canvas = document.getElementById('embedding-visualization');
        this.ctx = this.canvas.getContext('2d');
        
        // Dimension des embeddings
        this.dimension = 128;
        
        // Initialisation
        this.init();
    }
    
    async init() {
        try {
            // Attendre que la base de données soit initialisée
            await this.waitForDB();
            
            // Afficher les documents
            this.renderDocumentList();

            this.setupEventListeners();
        
            
            console.log('Démo initialisée avec succès');
        } catch (error) {
            console.error('Erreur lors de l\'initialisation:', error);
        }
    }
    
    async waitForDB() {
        // Attendre que la base de données soit disponible
        return new Promise((resolve) => {
            const checkDB = () => {
                if (window.db) {
                    resolve(window.db);
                } else {
                    setTimeout(checkDB, 100);
                }
            };
            checkDB();
        });
    }
    
    renderDocumentList() {
        // Afficher la liste des documents
        this.docListEl.innerHTML = '';
        
        const documents = window.db.collections.documents.documents;
        
        documents.forEach(doc => {
            const li = document.createElement('li');
            li.innerHTML = `
                <div class="mb-1">
                    <span class="font-medium">${doc.title}</span>
                </div>
                <div class="text-xs text-gray-600 mb-1">${doc.content.substring(0, 100)}...</div>
                <div class="flex flex-wrap gap-1">
                    ${doc.tags.map(tag => `<span class="bg-blue-100 text-blue-800 text-xs px-2 py-0.5 rounded">${tag}</span>`).join('')}
                </div>
            `;
            this.docListEl.appendChild(li);
        });
        
        // Mettre à jour les statistiques du corpus
        this.updateCorpusStats();
    }
    
    updateCorpusStats() {
        const documents = window.db.collections.documents.documents;
        this.corpusStatsEl.textContent = `${documents.length} documents, ${this.dimension} dimensions`;
    }
    
    visualizeEmbeddings() {
        // Visualiser les embeddings en 2D
        
        // Redimensionner le canvas
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
        
        // Effacer le canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        const documents = window.db.collections.documents.documents;
        
        // Projeter les embeddings en 2D
        const projections = {};
        documents.forEach(doc => {
            projections[doc.id] = this.projectEmbedding(doc.embedding);
        });
        
        // Normaliser les coordonnées pour s'adapter au canvas
        const allX = Object.values(projections).map(p => p.x);
        const allY = Object.values(projections).map(p => p.y);
        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        const minY = Math.min(...allY);
        const maxY = Math.max(...allY);
        
        const padding = 40;
        const scaleX = (this.canvas.width - 2 * padding) / (maxX - minX || 1);
        const scaleY = (this.canvas.height - 2 * padding) / (maxY - minY || 1);
        
        // Dessiner les points
        documents.forEach(doc => {
            const proj = projections[doc.id];
            
            const x = padding + (proj.x - minX) * scaleX;
            const y = padding + (proj.y - minY) * scaleY;
            
            // Dessiner le point
            this.ctx.beginPath();
            this.ctx.arc(x, y, 8, 0, 2 * Math.PI);
            
            // Couleur basée sur les tags du document
            const hue = (this.hashString(doc.tags.join('')) % 360);
            this.ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            this.ctx.fill();
            
            // Ajouter une bordure
            this.ctx.strokeStyle = `hsl(${hue}, 70%, 40%)`;
            this.ctx.lineWidth = 1;
            this.ctx.stroke();
            
            // Ajouter un label
            this.ctx.fillStyle = '#1e293b';
            this.ctx.font = '10px Inter, sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(doc.id, x, y - 12);
        });
    }
    
    projectEmbedding(embedding) {
        // Projection simplifiée d'un embedding en 2D
        // Dans une application réelle, on utiliserait t-SNE ou UMAP
        
        // Utiliser une projection linéaire simple basée sur des sommes pondérées
        let x = 0, y = 0;
        
        for (let i = 0; i < embedding.length; i++) {
            if (i % 2 === 0) {
                x += embedding[i] * Math.cos(i * 0.1);
            } else {
                y += embedding[i] * Math.sin(i * 0.1);
            }
        }
        
        return { x, y };
    }
    
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }
    
    setupEventListeners() {
        // Écouteur pour le formulaire de recherche
        this.searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.performSearch();
        });
        
    }
    
    generateQueryEmbedding(query) {
        // Générer un embedding pour la requête
        // Dans une application réelle, cela utiliserait le même modèle que pour les documents
        
        const dimension = window.db.collections.documents.documents[0].embedding.length;
        
        // Fonction qui génère un embedding simulé mais déterministe basé sur le texte
        const hash = this.hashString(query);
        const embedding = new Array(dimension).fill(0);
        
        // Générer un vecteur basé sur le hash du texte
        for (let i = 0; i < dimension; i++) {
            embedding[i] = Math.sin(hash * (i + 1) * 0.01) + Math.cos(hash * (i + 0.5) * 0.01);
        }
        
        // Normaliser le vecteur (norme L2 = 1)
        return this.normalizeVector(embedding);
    }
    
    normalizeVector(vector) {
        const norm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        return vector.map(val => val / norm);
    }
    
    performSearch() {
        const query = this.queryInput.value.trim();
        if (!query) return;
        
        // Afficher les statistiques de recherche
        this.searchStatsEl.classList.remove('hidden');
        
        // Récupérer les paramètres
        const algorithm = this.algorithmSelect ? this.algorithmSelect.value : 'hnsw';
        const metric = this.metricSelect ? this.metricSelect.value : 'cosine';
        const topK = this.topKInput ? parseInt(this.topKInput.value) : 5;
        const filterTags = this.filterTagsInput && this.filterTagsInput.value.trim() 
            ? this.filterTagsInput.value.trim().toLowerCase().split(/\s*,\s*/)
            : [];
        
        // Générer l'embedding de la requête
        const queryEmbedding = this.generateQueryEmbedding(query);
        
        // Mesurer le temps de recherche
        const startTime = performance.now();
        
        // Préparer le filtre si nécessaire
        let filter = null;
        if (filterTags.length > 0 && filterTags[0] !== '') {
            filter = {
                tags: {
                    $containsAny: filterTags
                }
            };
        }
        
        // Effectuer la recherche avec la base de données
        let results;
        try {
            results = window.db.search('documents', queryEmbedding, topK, {
                metricType: metric,
                filter: filter,
                algorithm: algorithm
            });
        } catch (error) {
            console.error('Erreur lors de la recherche:', error);
            results = [];
        }
        
        const endTime = performance.now();
        const searchTime = (endTime - startTime).toFixed(2);
        
        // Afficher le temps de recherche
        if (this.searchTimeEl) {
            this.searchTimeEl.textContent = searchTime;
        }
        
        // Afficher les résultats
        this.renderSearchResults(results);
        
        // Mettre en évidence les résultats dans la visualisation
        this.highlightSearchResults(results);
    }
    
    renderSearchResults(results) {
        this.resultsEl.innerHTML = '';
        
        if (results.length === 0) {
            this.resultsEl.innerHTML = '<div class="text-gray-500">Aucun résultat trouvé</div>';
            return;
        }
        
        results.forEach(result => {
            const doc = result.document;
            const resultEl = document.createElement('div');
            resultEl.className = 'bg-blue-50 rounded-lg p-3 mb-2';
            
            // Formater la distance/similarité
            let scoreText = '';
            const metric = this.metricSelect ? this.metricSelect.value : 'cosine';
            if (metric === 'cosine') {
                scoreText = `Similarité: ${result.distance.toFixed(3)}`;
            } else if (metric === 'euclidean') {
                scoreText = `Distance: ${result.distance.toFixed(3)}`;
            } else {
                scoreText = `Score: ${result.distance.toFixed(3)}`;
            }
            
            resultEl.innerHTML = `
                <div class="font-semibold text-blue-800">${doc.title}</div>
                <div class="text-sm text-gray-700 mb-1">${doc.content.substring(0, 150)}...</div>
                <div class="flex justify-between items-center">
                    <div class="flex flex-wrap gap-1">
                        ${doc.tags.map(tag => `<span class="bg-blue-200 text-blue-800 text-xs px-2 py-0.5 rounded">${tag}</span>`).join('')}
                    </div>
                    <div class="text-xs text-blue-600 font-medium">${scoreText}</div>
                </div>
            `;
            
            this.resultsEl.appendChild(resultEl);
        });
    }
    
    highlightSearchResults(results) {
        // Mettre à jour la visualisation pour mettre en évidence les résultats
        // Dessiner des cercles autour des résultats
        const docIds = results.map(r => r.id);
        
        // Projeter les embeddings en 2D
        const projections = {};
        const documents = window.db.collections.documents.documents;
        
        docIds.forEach(docId => {
            const doc = documents.find(d => d.id === docId);
            projections[docId] = this.projectEmbedding(doc.embedding);
        });
        
        // Normaliser les coordonnées
        const allX = Object.values(projections).map(p => p.x);
        const allY = Object.values(projections).map(p => p.y);
        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        const minY = Math.min(...allY);
        const maxY = Math.max(...allY);
        
        const padding = 40;
        const scaleX = (this.canvas.width - 2 * padding) / (maxX - minX || 1);
        const scaleY = (this.canvas.height - 2 * padding) / (maxY - minY || 1);
        
        // Dessiner des cercles autour des résultats
        docIds.forEach((docId, index) => {
            const proj = projections[docId];
            
            const x = padding + (proj.x - minX) * scaleX;
            const y = padding + (proj.y - minY) * scaleY;
            
            // Dessiner un cercle autour du point
            this.ctx.beginPath();
            this.ctx.arc(x, y, 12, 0, 2 * Math.PI);
            this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            
            // Ajouter un numéro de rang
            this.ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
            this.ctx.font = 'bold 10px Inter, sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`#${index + 1}`, x, y + 20);
        });
    }
}

// Initialiser la démo lorsque le DOM est chargé
document.addEventListener('DOMContentLoaded', () => {
    const demo = new VectorSearchDemoDB();
});


            // Demo corpus
            const docs = [
                "Introduction à l'apprentissage profond et aux réseaux de neurones",
                "Recherche sémantique avec embeddings de texte",
                "Clustering de données en haute dimension",
                "Bases vectorielles pour la recherche documentaire",
                "Applications de l'IA générative"
            ];
            // Simuler des embeddings (mêmes pour doc et requête)
            function fakeEmbed(text) {
                // Simple hash pour reproductibilité
                let hash = 0;
                for (let i = 0; i < text.length; i++) hash = ((hash << 5) - hash) + text.charCodeAt(i);
                hash = Math.abs(hash);
                const arr = [];
                for (let i = 0; i < 64; i++) arr.push(Math.sin(hash + i) + Math.cos(hash * (i + 1)));
                // Normalisation L2
                const norm = Math.sqrt(arr.reduce((s, v) => s + v * v, 0));
                return arr.map(v => v / norm);
            }
            // Similarité cosinus
            function cosineSim(a, b) {
                let dot = 0, na = 0, nb = 0;
                for (let i = 0; i < a.length; i++) {
                    dot += a[i] * b[i];
                    na += a[i] * a[i];
                    nb += b[i] * b[i];
                }
                return dot / (Math.sqrt(na) * Math.sqrt(nb));
            }
            // Affichage du corpus
            const docList = document.getElementById('doc-list');
            docs.forEach((d, i) => {
                const li = document.createElement('li');
                li.textContent = d;
                docList.appendChild(li);
            });
            // Recherche
            document.getElementById('search-form').addEventListener('submit', function(e) {
                e.preventDefault();
                const q = document.getElementById('query-input').value.trim();
                if (!q) return;
                const qEmb = fakeEmbed(q);
                // Calculer similarité cosinus
                const sims = docs.map((d, i) => ({
                    idx: i,
                    score: cosineSim(qEmb, fakeEmbed(d))
                }));
                sims.sort((a, b) => b.score - a.score);
                // Affichage résultats
                const results = document.getElementById('results');
                results.innerHTML = '';
                sims.slice(0, 3).forEach(({idx, score}) => {
                    const div = document.createElement('div');
                    div.className = "bg-blue-50 rounded p-2";
                    div.innerHTML = `<span class="font-semibold text-blue-700">${docs[idx]}</span><br>
                    <span class="text-xs text-gray-600">Score cosinus&nbsp;: ${score.toFixed(3)}</span>`;
                    results.appendChild(div);
                });
            });
            </script>
        </section>
    </main>
    
    <footer class="bg-gradient-to-r from-blue-700 via-blue-800 to-indigo-900 text-white py-10 px-4 sm:px-6 lg:px-8 shadow-inner">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center gap-6">
            <div class="flex items-center gap-4">
                <div class="bg-blue-500 rounded-full p-3 shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <circle cx="12" cy="12" r="10" stroke="white" stroke-width="2" fill="#3b82f6"/>
                        <path stroke="white" stroke-width="2" d="M12 6v6l4 2"/>
                    </svg>
                </div>
                <div>
                    <h3 class="text-2xl font-bold mb-1 tracking-tight">Labo Vectoriel IA</h3>
                    <p class="text-blue-100 text-sm">Bases vectorielles &amp; moteurs de similarité pour l'IA</p>
                </div>
            </div>
            <div class="flex flex-col md:items-end gap-2">
                <div class="flex gap-3 mb-2">
                    <a href="#introduction" class="text-blue-200 hover:text-white transition font-medium">Introduction</a>
                    <a href="#fondements" class="text-blue-200 hover:text-white transition font-medium">Maths</a>
                    <a href="#algorithmes" class="text-blue-200 hover:text-white transition font-medium">Algorithmes</a>
                    <a href="#systemes" class="text-blue-200 hover:text-white transition font-medium">Systèmes</a>
                </div>
                <div class="flex items-center gap-2">
                    <span class="text-blue-200 text-xs">© 2025-202X Labo Vectoriel</span>
                    <span class="text-blue-400 text-xs">|</span>
                    <a href="https://github.com/feur25" target="_blank" rel="noopener" class="hover:text-blue-300 text-xs flex items-center gap-1">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 .5C5.73.5.5 5.73.5 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.17.08 1.78 1.2 1.78 1.2 1.04 1.78 2.73 1.27 3.4.97.11-.75.41-1.27.74-1.56-2.56-.29-5.26-1.28-5.26-5.7 0-1.26.45-2.29 1.19-3.09-.12-.29-.52-1.46.11-3.05 0 0 .98-.31 3.2 1.18a11.1 11.1 0 0 1 2.92-.39c.99 0 1.99.13 2.92.39 2.22-1.49 3.2-1.18 3.2-1.18.63 1.59.23 2.76.11 3.05.74.8 1.19 1.83 1.19 3.09 0 4.43-2.7 5.41-5.27 5.7.42.36.79 1.09.79 2.2 0 1.59-.01 2.87-.01 3.26 0 .31.21.68.8.56C20.71 21.39 24 17.08 24 12c0-6.27-5.23-11.5-12-11.5z"/></svg>
                        <span>GitHub</span>
                    </a>
                </div>
            </div>
        </div>
    </footer>
    
    <script>
        // Render LaTeX formulas
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
            
            // Tab switching
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    
                    // Update active tab button
                    tabButtons.forEach(btn => {
                        if (btn.getAttribute('data-tab') === tabId) {
                            btn.classList.add('border-blue-500', 'text-blue-600');
                            btn.classList.remove('border-transparent', 'text-gray-500');
                        } else {
                            btn.classList.remove('border-blue-500', 'text-blue-600');
                            btn.classList.add('border-transparent', 'text-gray-500');
                        }
                    });
                    
                    // Update active tab content
                    tabContents.forEach(content => {
                        if (content.id === `${tabId}-tab`) {
                            content.classList.add('active');
                            content.classList.remove('hidden');
                        } else {
                            content.classList.remove('active');
                            content.classList.add('hidden');
                        }
                    });
                });
            });
            
            // Cosine Similarity Chart
            const cosineCtx = document.getElementById('cosine-similarity-chart').getContext('2d');
            new Chart(cosineCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Vecteurs',
                        data: [
                            { x: 0, y: 0 },
                            { x: 1, y: 0 },
                            { x: 0.866, y: 0.5 }
                        ],
                        backgroundColor: [
                            'rgba(59, 130, 246, 0.5)',
                            'rgba(16, 185, 129, 0.5)',
                            'rgba(239, 68, 68, 0.5)'
                        ],
                        pointRadius: 6
                    }]
                },
                options: {
                    scales: {
                        x: {
                            min: -0.2,
                            max: 1.2,
                            grid: {
                                display: true
                            }
                        },
                        y: {
                            min: -0.2,
                            max: 0.7,
                            grid: {
                                display: true
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const labels = ['Origine', 'Vecteur A', 'Vecteur B'];
                                    const angles = ['', '', 'Angle: 30°, Similarité: 0.866'];
                                    return [labels[context.dataIndex], angles[context.dataIndex]];
                                }
                            }
                        }
                    }
                }
            });
            
            // Complexity Chart
            const complexityCtx = document.getElementById('complexity-chart').getContext('2d');
            new Chart(complexityCtx, {
                type: 'line',
                data: {
                    labels: ['10', '100', '1K', '10K', '100K', '1M', '10M'],
                    datasets: [{
                        label: 'Recherche exhaustive O(n·d)',
                        data: [1, 10, 100, 1000, 10000, 100000, 1000000],
                        borderColor: 'rgba(239, 68, 68, 0.8)',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 2,
                        fill: true
                    }, {
                        label: 'HNSW O(log(n)·d)',
                        data: [1, 2, 3, 4, 5, 6, 7],
                        borderColor: 'rgba(16, 185, 129, 0.8)',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    scales: {
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Temps de recherche (relatif)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Nombre de vecteurs'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Complexité des algorithmes de recherche'
                        }
                    }
                }
            });
            
            // Dimensionality Chart
            const dimensionalityCtx = document.getElementById('dimensionality-chart').getContext('2d');
            new Chart(dimensionalityCtx, {
                type: 'line',
                data: {
                    labels: ['2', '4', '8', '16', '32', '64', '128', '256', '512', '1024'],
                    datasets: [{
                        label: 'Contraste des distances (max/min)',
                        data: [10, 8, 6, 4, 3, 2, 1.5, 1.3, 1.2, 1.1],
                        borderColor: 'rgba(59, 130, 246, 0.8)',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Contraste (ratio max/min)'
                            },
                            min: 0
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Dimension'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Fléau de la dimensionnalité: Contraste des distances'
                        }
                    }
                }
            });
            
            // Create embedding animation
            const embeddingAnimation = document.getElementById('embedding-animation');
            
            // Create SVG for embedding animation
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.setAttribute("viewBox", "0 0 300 200");
            embeddingAnimation.appendChild(svg);
            
            // Create input objects (text, image)
            const inputGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            
            // Text input
            const textRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            textRect.setAttribute("x", "20");
            textRect.setAttribute("y", "40");
            textRect.setAttribute("width", "80");
            textRect.setAttribute("height", "30");
            textRect.setAttribute("rx", "4");
            textRect.setAttribute("fill", "#bfdbfe");
            textRect.setAttribute("stroke", "#3b82f6");
            textRect.setAttribute("stroke-width", "1");
            inputGroup.appendChild(textRect);
            
            const textLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textLabel.setAttribute("x", "60");
            textLabel.setAttribute("y", "60");
            textLabel.setAttribute("text-anchor", "middle");
            textLabel.setAttribute("fill", "#1e40af");
            textLabel.setAttribute("font-size", "12");
            textLabel.textContent = "Texte";
            inputGroup.appendChild(textLabel);
            
            // Image input
            const imageRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            imageRect.setAttribute("x", "20");
            imageRect.setAttribute("y", "90");
            imageRect.setAttribute("width", "80");
            imageRect.setAttribute("height", "60");
            imageRect.setAttribute("rx", "4");
            imageRect.setAttribute("fill", "#c7d2fe");
            imageRect.setAttribute("stroke", "#6366f1");
            imageRect.setAttribute("stroke-width", "1");
            inputGroup.appendChild(imageRect);
            
            // Simple image icon
            const imageLine1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            imageLine1.setAttribute("x1", "30");
            imageLine1.setAttribute("y1", "110");
            imageLine1.setAttribute("x2", "50");
            imageLine1.setAttribute("y2", "110");
            imageLine1.setAttribute("stroke", "#4f46e5");
            imageLine1.setAttribute("stroke-width", "2");
            inputGroup.appendChild(imageLine1);
            
            const imageLine2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            imageLine2.setAttribute("x1", "30");
            imageLine2.setAttribute("y1", "120");
            imageLine2.setAttribute("x2", "70");
            imageLine2.setAttribute("y2", "120");
            imageLine2.setAttribute("stroke", "#4f46e5");
            imageLine2.setAttribute("stroke-width", "2");
            inputGroup.appendChild(imageLine2);
            
            const imageLine3 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            imageLine3.setAttribute("x1", "30");
            imageLine3.setAttribute("y1", "130");
            imageLine3.setAttribute("x2", "60");
            imageLine3.setAttribute("y2", "130");
            imageLine3.setAttribute("stroke", "#4f46e5");
            imageLine3.setAttribute("stroke-width", "2");
            inputGroup.appendChild(imageLine3);
            
            const imageLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            imageLabel.setAttribute("x", "60");
            imageLabel.setAttribute("y", "155");
            imageLabel.setAttribute("text-anchor", "middle");
            imageLabel.setAttribute("fill", "#4f46e5");
            imageLabel.setAttribute("font-size", "12");
            imageLabel.textContent = "Image";
            inputGroup.appendChild(imageLabel);
            
            svg.appendChild(inputGroup);
            
            // Create embedding model box
            const modelRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            modelRect.setAttribute("x", "130");
            modelRect.setAttribute("y", "70");
            modelRect.setAttribute("width", "60");
            modelRect.setAttribute("height", "60");
            modelRect.setAttribute("rx", "8");
            modelRect.setAttribute("fill", "#fef3c7");
            modelRect.setAttribute("stroke", "#d97706");
            modelRect.setAttribute("stroke-width", "2");
            svg.appendChild(modelRect);
            
            const modelLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            modelLabel.setAttribute("x", "160");
            modelLabel.setAttribute("y", "105");
            modelLabel.setAttribute("text-anchor", "middle");
            modelLabel.setAttribute("fill", "#92400e");
            modelLabel.setAttribute("font-size", "12");
            modelLabel.textContent = "Modèle";
            svg.appendChild(modelLabel);
            
            // Create vector space
            const vectorSpaceRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            vectorSpaceRect.setAttribute("x", "220");
            vectorSpaceRect.setAttribute("y", "40");
            vectorSpaceRect.setAttribute("width", "60");
            vectorSpaceRect.setAttribute("height", "120");
            vectorSpaceRect.setAttribute("rx", "4");
            vectorSpaceRect.setAttribute("fill", "#dbeafe");
            vectorSpaceRect.setAttribute("stroke", "#3b82f6");
            vectorSpaceRect.setAttribute("stroke-width", "1");
            svg.appendChild(vectorSpaceRect);
            
            // Create vectors in the space
            const vector1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            vector1.setAttribute("x1", "250");
            vector1.setAttribute("y1", "100");
            vector1.setAttribute("x2", "250");
            vector1.setAttribute("y2", "70");
            vector1.setAttribute("stroke", "#3b82f6");
            vector1.setAttribute("stroke-width", "2");
            svg.appendChild(vector1);
            
            const vector1Arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            vector1Arrow.setAttribute("points", "250,65 246,72 254,72");
            vector1Arrow.setAttribute("fill", "#3b82f6");
            svg.appendChild(vector1Arrow);
            
            const vector2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            vector2.setAttribute("x1", "250");
            vector2.setAttribute("y1", "100");
            vector2.setAttribute("x2", "270");
            vector2.setAttribute("y2", "80");
            vector2.setAttribute("stroke", "#6366f1");
            vector2.setAttribute("stroke-width", "2");
            svg.appendChild(vector2);
            
            const vector2Arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            vector2Arrow.setAttribute("points", "274,76 266,78 270,86");
            vector2Arrow.setAttribute("fill", "#6366f1");
            svg.appendChild(vector2Arrow);
            
            const vectorSpaceLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            vectorSpaceLabel.setAttribute("x", "250");
            vectorSpaceLabel.setAttribute("y", "175");
            vectorSpaceLabel.setAttribute("text-anchor", "middle");
            vectorSpaceLabel.setAttribute("fill", "#1e40af");
            vectorSpaceLabel.setAttribute("font-size", "12");
            vectorSpaceLabel.textContent = "Espace Vectoriel";
            svg.appendChild(vectorSpaceLabel);
            
            // Create arrows from inputs to model
            const arrow1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            arrow1.setAttribute("x1", "100");
            arrow1.setAttribute("y1", "55");
            arrow1.setAttribute("x2", "125");
            arrow1.setAttribute("y2", "85");
            arrow1.setAttribute("stroke", "#94a3b8");
            arrow1.setAttribute("stroke-width", "1.5");
            arrow1.setAttribute("stroke-dasharray", "4");
            svg.appendChild(arrow1);
            
            const arrow2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            arrow2.setAttribute("x1", "100");
            arrow2.setAttribute("y1", "120");
            arrow2.setAttribute("x2", "125");
            arrow2.setAttribute("y2", "100");
            arrow2.setAttribute("stroke", "#94a3b8");
            arrow2.setAttribute("stroke-width", "1.5");
            arrow2.setAttribute("stroke-dasharray", "4");
            svg.appendChild(arrow2);
            
            // Create arrow from model to vector space
            const arrow3 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            arrow3.setAttribute("x1", "190");
            arrow3.setAttribute("y1", "100");
            arrow3.setAttribute("x2", "215");
            arrow3.setAttribute("y2", "100");
            arrow3.setAttribute("stroke", "#94a3b8");
            arrow3.setAttribute("stroke-width", "1.5");
            svg.appendChild(arrow3);
            
            const arrow3Head = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            arrow3Head.setAttribute("points", "215,100 210,96 210,104");
            arrow3Head.setAttribute("fill", "#94a3b8");
            svg.appendChild(arrow3Head);
            
            // Animation
            let animationStep = 0;
            
            function animateEmbedding() {
                animationStep = (animationStep + 1) % 4;
                
                if (animationStep === 1) {
                    // Highlight text input
                    textRect.setAttribute("fill", "#93c5fd");
                    textRect.setAttribute("stroke-width", "2");
                    imageRect.setAttribute("fill", "#c7d2fe");
                    imageRect.setAttribute("stroke-width", "1");
                    
                    // Highlight arrow
                    arrow1.setAttribute("stroke", "#3b82f6");
                    arrow1.setAttribute("stroke-width", "2");
                    arrow2.setAttribute("stroke", "#94a3b8");
                    arrow2.setAttribute("stroke-width", "1.5");
                    
                    // Highlight vector
                    vector1.setAttribute("stroke-width", "3");
                    vector2.setAttribute("stroke-width", "2");
                } else if (animationStep === 2) {
                    // Reset text, highlight image
                    textRect.setAttribute("fill", "#bfdbfe");
                    textRect.setAttribute("stroke-width", "1");
                    imageRect.setAttribute("fill", "#a5b4fc");
                    imageRect.setAttribute("stroke-width", "2");
                    
                    // Highlight arrows
                    arrow1.setAttribute("stroke", "#94a3b8");
                    arrow1.setAttribute("stroke-width", "1.5");
                    arrow2.setAttribute("stroke", "#6366f1");
                    arrow2.setAttribute("stroke-width", "2");
                    
                    // Highlight vectors
                    vector1.setAttribute("stroke-width", "2");
                    vector2.setAttribute("stroke-width", "3");
                } else {
                    // Reset all
                    textRect.setAttribute("fill", "#bfdbfe");
                    textRect.setAttribute("stroke-width", "1");
                    imageRect.setAttribute("fill", "#c7d2fe");
                    imageRect.setAttribute("stroke-width", "1");
                    
                    arrow1.setAttribute("stroke", "#94a3b8");
                    arrow1.setAttribute("stroke-width", "1.5");
                    arrow2.setAttribute("stroke", "#94a3b8");
                    arrow2.setAttribute("stroke-width", "1.5");
                    
                    vector1.setAttribute("stroke-width", "2");
                    vector2.setAttribute("stroke-width", "2");
                }
                
                setTimeout(animateEmbedding, 1500);
            }
            
            // Start animation
            animateEmbedding();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9542f063f0efb416',t:'MTc1MDY3MDczNi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script><iframe height="1" width="1" style="position: absolute; top: 0px; left: 0px; border: none; visibility: hidden;"></iframe>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        // Activation de la coloration syntaxique
        hljs.highlightAll();

        // Fonctionnalité de copie pour tous les boutons .copy-btn
        document.querySelectorAll('.copy-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
            // Trouver le code associé à ce bouton
            const code = btn.closest('.code-container').querySelector('code').textContent;
            navigator.clipboard.writeText(code).then(() => {
                btn.textContent = 'Copié!';
                btn.classList.add('copied');
                setTimeout(() => {
                btn.textContent = 'Copier';
                btn.classList.remove('copied');
                }, 2000);
            });
            });
        });
    </script>
</body></html>